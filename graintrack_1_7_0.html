<!--
  GrainTrack Suite v1.7.2
  Grain marketing and inventory management
  https://github.com/BaldwinAg/grain-inventory
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GrainTrack Suite v1.7.2</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; }
    .modified-row { background-color: #fef9c3 !important; }
  </style>
</head>
<body class="bg-gray-50">
  <div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useCallback } = React;

// ============================================================================
// SUPABASE CLIENT
// ============================================================================
const SUPABASE_URL = 'https://xehapaasizntuzqzvwej.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhlaGFwYWFzaXpudHV6cXp2d2VqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgzMTkwOTksImV4cCI6MjA4Mzg5NTA5OX0.JTtRaVRfZ4DNddTdT2BsKgCNabErgsCB0rBCHlK0mbA';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

async function testConnection() {
  try {
    const { error } = await supabase.from('commodities').select('id').limit(1);
    return !error;
  } catch {
    return false;
  }
}

// ============================================================================
// BARCHART INTEGRATION
// ============================================================================

// Map commodity names to Barchart symbol prefixes
// Barchart uses symbols like ZCZ25 (Corn Dec 2025), ZSX26 (Soybeans Nov 2026)
const BARCHART_COMMODITY_MAP = {
  'Corn': 'ZC',
  'Soybeans': 'ZS',
  'Wheat': 'ZW',
  'KC Wheat': 'KE',
  'Milo': null,  // No milo futures
  'Grain Sorghum': null
};

// Reverse map for looking up commodity from prefix
const BARCHART_PREFIX_TO_COMMODITY = {
  'ZC': 'Corn',
  'ZS': 'Soybeans',
  'ZW': 'Wheat',
  'KE': 'KC Wheat'
};

// Month codes for futures/options
const MONTH_CODES = {
  'F': { month: 'Jan', num: 1 },
  'G': { month: 'Feb', num: 2 },
  'H': { month: 'Mar', num: 3 },
  'J': { month: 'Apr', num: 4 },
  'K': { month: 'May', num: 5 },
  'M': { month: 'Jun', num: 6 },
  'N': { month: 'Jul', num: 7 },
  'Q': { month: 'Aug', num: 8 },
  'U': { month: 'Sep', num: 9 },
  'V': { month: 'Oct', num: 10 },
  'X': { month: 'Nov', num: 11 },
  'Z': { month: 'Dec', num: 12 }
};

// ============================================================================
// ICONS (using Lucide) with text fallback
// ============================================================================
const ICON_FALLBACKS = {
  'pencil': 'âœï¸', 'trash-2': 'ðŸ—‘ï¸', 'eye': 'ðŸ‘ï¸', 'eye-off': 'âŠ˜', 'plus': '+', 'check': 'âœ”', 'x': 'âœ•',
  'refresh-cw': 'â†»', 'download': 'â¬‡ï¸', 'file-text': 'ðŸ“„', 'home': 'ðŸ ', 'settings': 'âš™ï¸',
  'layout-dashboard': 'ðŸ“Š', 'plus-circle': 'âŠ•', 'wheat': 'ðŸŒ¾', 'shield': 'ðŸ›¡ï¸', 'building-2': 'ðŸ¢',
  'warehouse': 'ðŸ­', 'package': 'ðŸ“¦', 'menu': 'â˜°', 'chevron-down': 'â–¼', 'chevron-up': 'â–²',
  'alert-circle': 'âš ï¸', 'info': 'â„¹ï¸', 'search': 'ðŸ”', 'trending-up': 'ðŸ“ˆ', 'dollar-sign': '$',
  'save': 'ðŸ’¾', 'edit': 'âœï¸', 'edit-2': 'âœï¸', 'star': 'â­', 'upload': 'â¬†ï¸', 'file-up': 'ðŸ“¤', 'arrow-right-left': 'â‡„', 'link': 'ðŸ”—', 'bar-chart-3': 'ðŸ“Š',
  'scale': 'âš–ï¸', 'history': 'ðŸ•', 'chevron-right': 'â–¶', 'map-pin': 'ðŸ“', 'users': 'ðŸ‘¥',
  'clipboard-check': 'ðŸ“‹', 'alert-triangle': 'âš ï¸', 'check-circle': 'âœ…', 'x-circle': 'âŒ',
  'loader': 'âŸ³', 'minus': '-', 'arrow-down': 'â†“', 'arrow-up': 'â†‘',
  'log-out': 'â†’', 'user': 'ðŸ‘¤'
};

function Icon({ name, size = 20, className = '' }) {
  const ref = React.useRef(null);
  
  useEffect(() => {
    if (ref.current) {
      try {
        if (window.lucide?.icons?.[name]) {
          const svg = lucide.icons[name].toSvg({ width: size, height: size });
          ref.current.innerHTML = svg;
        } else {
          // Fallback to emoji/text
          ref.current.innerHTML = ICON_FALLBACKS[name] || '*';
        }
      } catch (e) {
        ref.current.innerHTML = ICON_FALLBACKS[name] || '*';
      }
    }
  }, [name, size]);
  
  return <span ref={ref} className={`inline-flex items-center justify-center ${className}`} style={{ minWidth: size, minHeight: size }} />;
}

// ============================================================================
// TOAST NOTIFICATION SYSTEM
// ============================================================================
const ToastContext = React.createContext(null);

function ToastProvider({ children }) {
  const [toasts, setToasts] = useState([]);

  const addToast = useCallback((message, options = {}) => {
    const id = Date.now();
    const toast = {
      id,
      message,
      type: options.type || 'info', // 'info', 'success', 'error', 'warning'
      undoAction: options.undoAction || null,
      duration: options.duration || 5000
    };
    setToasts(prev => [...prev, toast]);

    // Auto-remove after duration (unless it has undo action)
    if (!options.undoAction) {
      setTimeout(() => {
        setToasts(prev => prev.filter(t => t.id !== id));
      }, toast.duration);
    }

    return id;
  }, []);

  const removeToast = useCallback((id) => {
    setToasts(prev => prev.filter(t => t.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ addToast, removeToast }}>
      {children}
      <ToastContainer toasts={toasts} onRemove={removeToast} />
    </ToastContext.Provider>
  );
}

function ToastContainer({ toasts, onRemove }) {
  return (
    <div className="fixed bottom-4 right-4 z-50 flex flex-col gap-2">
      {toasts.map(toast => (
        <Toast key={toast.id} toast={toast} onRemove={onRemove} />
      ))}
    </div>
  );
}

function Toast({ toast, onRemove }) {
  const [timeLeft, setTimeLeft] = useState(5);
  const timerRef = React.useRef(null);

  useEffect(() => {
    if (toast.undoAction) {
      timerRef.current = setInterval(() => {
        setTimeLeft(prev => {
          if (prev <= 1) {
            clearInterval(timerRef.current);
            onRemove(toast.id);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }
    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, [toast.id, toast.undoAction, onRemove]);

  const handleUndo = async () => {
    if (timerRef.current) clearInterval(timerRef.current);
    if (toast.undoAction) {
      await toast.undoAction();
    }
    onRemove(toast.id);
  };

  const bgColor = {
    info: 'bg-gray-800',
    success: 'bg-green-600',
    error: 'bg-red-600',
    warning: 'bg-amber-600'
  }[toast.type] || 'bg-gray-800';

  return (
    <div className={`${bgColor} text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-3 min-w-72`}>
      <span className="flex-1">{toast.message}</span>
      {toast.undoAction && (
        <>
          <button
            onClick={handleUndo}
            className="font-semibold hover:underline"
          >
            Undo ({timeLeft}s)
          </button>
        </>
      )}
      <button onClick={() => onRemove(toast.id)} className="hover:opacity-75">
        <Icon name="x" size={16} />
      </button>
    </div>
  );
}

function useToast() {
  const context = React.useContext(ToastContext);
  if (!context) throw new Error('useToast must be used within ToastProvider');
  return context;
}

// ============================================================================
// CONFIRMATION MODAL
// ============================================================================
function ConfirmModal({ isOpen, title, message, confirmText, cancelText, onConfirm, onCancel, variant }) {
  if (!isOpen) return null;

  const confirmBg = variant === 'danger' ? 'bg-red-600 hover:bg-red-700' : 'bg-amber-600 hover:bg-amber-700';

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="fixed inset-0 bg-black bg-opacity-50" onClick={onCancel} />
      <div className="relative bg-white rounded-lg shadow-xl p-6 max-w-md w-full mx-4">
        <h3 className="text-lg font-semibold text-gray-900 mb-2">{title || 'Confirm'}</h3>
        <p className="text-gray-600 mb-6">{message}</p>
        <div className="flex justify-end gap-3">
          <button
            onClick={onCancel}
            className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg"
          >
            {cancelText || 'Cancel'}
          </button>
          <button
            onClick={onConfirm}
            className={`px-4 py-2 text-white rounded-lg ${confirmBg}`}
          >
            {confirmText || 'Confirm'}
          </button>
        </div>
      </div>
    </div>
  );
}

// ============================================================================
// AUDIT LOGGING
// ============================================================================
async function logAudit(tableName, recordId, action, oldValues = null, newValues = null) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    await supabase.from('audit_log').insert([{
      user_id: user?.id || null,
      user_email: user?.email || null,
      table_name: tableName,
      record_id: recordId,
      action: action,
      old_values: oldValues,
      new_values: newValues
    }]);
  } catch (e) {
    console.error('Audit log error:', e);
  }
}

// Soft delete helper - marks record as deleted instead of removing
async function softDelete(tableName, id) {
  const deletedAt = new Date().toISOString();
  const { error } = await supabase
    .from(tableName)
    .update({ deleted_at: deletedAt })
    .eq('id', id);
  if (error) throw error;
  return deletedAt;
}

// Restore helper - removes deleted_at timestamp
async function restoreRecord(tableName, id) {
  const { error } = await supabase
    .from(tableName)
    .update({ deleted_at: null })
    .eq('id', id);
  if (error) throw error;
}

// ============================================================================
// SERVICES
// ============================================================================

// Commodities
async function getCommodities() {
  const { data, error } = await supabase
    .from('commodities')
    .select('*')
    .eq('active', true)
    .order('sort_order');
  if (error) { console.error('Error fetching commodities:', error); return []; }
  return data || [];
}

// Buyers
async function getBuyers(includeInactive = false, includeDeleted = false) {
  let query = supabase.from('buyers').select('*').order('name');
  if (!includeInactive) query = query.eq('active', true);
  if (!includeDeleted) query = query.is('deleted_at', null);
  const { data, error } = await query;
  if (error) { console.error('Error fetching buyers:', error); return []; }
  return data || [];
}

async function createBuyer(name) {
  const { data, error } = await supabase
    .from('buyers')
    .insert([{ name, active: true }])
    .select()
    .single();
  if (error) throw error;
  return data;
}

async function updateBuyer(id, updates) {
  const { data, error } = await supabase
    .from('buyers')
    .update(updates)
    .eq('id', id)
    .select()
    .single();
  if (error) throw error;
  return data;
}

async function deleteBuyer(id) {
  // Get current values for audit log
  const { data: oldRecord } = await supabase.from('buyers').select('*').eq('id', id).single();

  // Soft delete
  await softDelete('buyers', id);

  // Log audit
  await logAudit('buyers', id, 'DELETE', oldRecord, null);

  return oldRecord; // Return for undo
}

// Production / Fields
async function getFieldsForGrain() {
  const { data: grainSettings } = await supabase
    .from('grain_field_settings')
    .select('field_id, is_active_for_grain');

  const activeFieldIds = new Set(
    (grainSettings || []).filter(s => s.is_active_for_grain).map(s => s.field_id)
  );

  const { data: farms, error: farmsError } = await supabase
    .from('farms')
    .select('id, name, adams_grain_share, active')
    .gt('adams_grain_share', 0)
    .eq('active', true);

  if (farmsError || !farms) return [];

  const farmMap = new Map(farms.map(f => [f.id, f]));

  const { data: fields, error: fieldsError } = await supabase
    .from('fields')
    .select('id, farm_id, name, acres, tenant_share, active')
    .in('farm_id', farms.map(f => f.id))
    .eq('active', true)
    .order('name');

  if (fieldsError || !fields) return [];

  const hasGrainSettings = grainSettings && grainSettings.length > 0;

  return fields
    .filter(f => !hasGrainSettings || activeFieldIds.has(f.id))
    .map(f => {
      const farm = farmMap.get(f.farm_id);
      return {
        ...f,
        farm_name: farm?.name || 'Unknown',
        effective_share: (f.tenant_share || 1) * (farm?.adams_grain_share || 1)
      };
    });
}

async function getProductionByCropYear(cropYear, commodityId, includeDeleted = false) {
  const fields = await getFieldsForGrain();
  if (!fields.length) return [];

  const fieldIds = fields.map(f => f.id);

  let query = supabase
    .from('field_crop_years')
    .select(`*, commodities:commodity_id (id, name)`)
    .eq('crop_year', cropYear)
    .in('field_id', fieldIds);

  if (commodityId) query = query.eq('commodity_id', commodityId);
  if (!includeDeleted) query = query.is('deleted_at', null);

  const { data, error } = await query;
  if (error) { console.error('Error fetching production:', error); return []; }

  const fieldMap = new Map(fields.map(f => [f.id, f]));

  return (data || []).map(row => {
    const field = fieldMap.get(row.field_id);
    const effectiveShare = row.share_override ?? field?.effective_share ?? 1;
    const expectedMarketable = (row.planted_acres || 0) * (row.estimated_yield || 0) * effectiveShare;
    const actualMarketable = row.actual_production ? row.actual_production * effectiveShare : null;

    // Build display name
    const commodityName = row.commodities?.name || 'Unknown';
    let displayName = commodityName;
    if (row.is_irrigated) displayName += ' IR';
    if (row.is_double_crop) displayName += ' (DC)';

    return {
      ...row,
      field_name: field?.name || 'Unknown',
      farm_name: field?.farm_name || 'Unknown',
      field_acres: field?.acres || 0,
      tenant_share: field?.tenant_share || 1,
      adams_grain_share: field?.effective_share ? field.effective_share / (field.tenant_share || 1) : 1,
      effective_share: effectiveShare,
      commodity_name: commodityName,
      display_name: displayName,
      expected_marketable: expectedMarketable,
      actual_marketable: actualMarketable
    };
  });
}

async function getProductionSummary(cropYear, byPractice = false) {
  const production = await getProductionByCropYear(cropYear);
  const summary = new Map();

  for (const row of production) {
    let key = row.commodity_id;
    if (byPractice) {
      // Create a compound key based on practice
      const practiceKey = row.is_double_crop ? 'DC' : (row.is_irrigated ? 'IR' : 'DL');
      key = `${row.commodity_id}|${practiceKey}`;
    }

    const existing = summary.get(key);
    if (existing) {
      existing.expected += row.expected_marketable;
      if (row.actual_marketable !== null) {
        existing.actual = (existing.actual || 0) + row.actual_marketable;
      }
    } else {
      summary.set(key, {
        commodity_id: row.commodity_id,
        commodity_name: row.commodity_name,
        is_irrigated: byPractice ? row.is_irrigated : null,
        is_double_crop: byPractice ? row.is_double_crop : null,
        expected: row.expected_marketable,
        actual: row.actual_marketable
      });
    }
  }

  return Array.from(summary.values()).map(s => ({
    commodity_id: s.commodity_id,
    commodity_name: s.commodity_name,
    is_irrigated: s.is_irrigated,
    is_double_crop: s.is_double_crop,
    expected_production: s.expected,
    actual_production: s.actual
  }));
}

async function createCropEntry(crop) {
  const { data, error } = await supabase
    .from('field_crop_years')
    .insert([{
      field_id: crop.field_id,
      crop_year: crop.crop_year,
      commodity_id: crop.commodity_id,
      subcategory_id: null,
      planted_acres: crop.planted_acres,
      estimated_yield: crop.estimated_yield,
      actual_production: null,
      share_override: crop.share_override || null,
      is_irrigated: crop.is_irrigated || false,
      is_double_crop: crop.is_double_crop || false,
      status: 'planned',
      notes: null
    }])
    .select()
    .single();

  if (error) { console.error('Error creating crop entry:', error); return null; }
  return data;
}

async function updateProduction(id, updates) {
  const { data, error } = await supabase
    .from('field_crop_years')
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq('id', id)
    .select()
    .single();

  if (error) { console.error('Error updating production:', error); return null; }
  return data;
}

async function deleteProduction(id) {
  // Get current values for audit log
  const { data: oldRecord } = await supabase.from('field_crop_years').select('*').eq('id', id).single();

  // Soft delete
  await softDelete('field_crop_years', id);

  // Log audit
  await logAudit('field_crop_years', id, 'DELETE', oldRecord, null);

  return oldRecord; // Return for undo
}

// Restore a soft-deleted production record
async function restoreProduction(id) {
  const { data: record } = await supabase.from('field_crop_years').select('*').eq('id', id).single();

  await restoreRecord('field_crop_years', id);

  // Log audit
  await logAudit('field_crop_years', id, 'RESTORE', null, record);

  return true;
}

// Grain Field Settings
async function getGrainFieldSettings() {
  const { data, error } = await supabase.from('grain_field_settings').select('*');
  if (error) { console.error('Error fetching grain field settings:', error); return []; }
  return data || [];
}

async function updateGrainFieldSetting(fieldId, isActive) {
  const { data: existing } = await supabase
    .from('grain_field_settings')
    .select('id')
    .eq('field_id', fieldId)
    .maybeSingle();

  if (existing) {
    const { error } = await supabase
      .from('grain_field_settings')
      .update({ is_active_for_grain: isActive })
      .eq('field_id', fieldId);
    if (error) { console.error('Error updating grain field setting:', error); return false; }
  } else {
    const { error } = await supabase
      .from('grain_field_settings')
      .insert([{ field_id: fieldId, is_active_for_grain: isActive }]);
    if (error) { console.error('Error creating grain field setting:', error); return false; }
  }
  return true;
}

// Contracts
async function getContracts(cropYear, commodityId, includeOptionQuotes = true, includeDeleted = false) {
  let query = supabase
    .from('contracts')
    .select(`*, commodities:commodity_id (id, name), buyers:buyer_id (id, name)`)
    .neq('status', 'CANCELLED')
    .order('contract_date', { ascending: false });

  if (cropYear) query = query.eq('crop_year', cropYear);
  if (commodityId) query = query.eq('commodity_id', commodityId);
  if (!includeDeleted) query = query.is('deleted_at', null);

  const { data, error } = await query;
  if (error) { console.error('Error fetching contracts:', error); return []; }

  // Get option quotes for P&L calculation
  let optionQuotes = [];
  if (includeOptionQuotes) {
    optionQuotes = await getOptionQuotes();
  }

  // Group contracts by strategy_group_id for multi-leg strategy display
  const strategyGroups = new Map();
  (data || []).forEach(c => {
    if (c.strategy_group_id) {
      if (!strategyGroups.has(c.strategy_group_id)) {
        strategyGroups.set(c.strategy_group_id, []);
      }
      strategyGroups.get(c.strategy_group_id).push(c);
    }
  });

  return (data || []).map(contract => {
    let effectivePrice = 0;
    if (contract.contract_type === 'CASH') effectivePrice = contract.cash_price || 0;
    else if (contract.contract_type === 'FUTURES' || contract.contract_type === 'HTA')
      effectivePrice = (contract.futures_price || 0) + (contract.expected_basis || 0);
    else if (contract.contract_type === 'BASIS') effectivePrice = contract.basis || 0;
    else if (contract.contract_type === 'OPTIONS') effectivePrice = contract.strike_price || 0;

    // Get strategy group members (excluding self)
    const strategyMembers = contract.strategy_group_id
      ? strategyGroups.get(contract.strategy_group_id).filter(c => c.id !== contract.id)
      : [];

    // Match option contracts to quotes for P&L
    let optionQuote = null;
    let optionPnL = null;
    if (contract.contract_type === 'OPTIONS' && optionQuotes.length > 0) {
      const commodityName = contract.commodities?.name;
      // Find matching quote by commodity, option type, strike, and futures month
      optionQuote = optionQuotes.find(q =>
        q.commodity_name === commodityName &&
        q.option_type === contract.option_type &&
        Math.abs(q.strike_price - contract.strike_price) < 0.01 &&
        q.futures_month === contract.futures_month
      );

      if (optionQuote && contract.premium) {
        const isShort = contract.position_type === 'SHORT';
        // P&L calculation:
        // Long: (current - paid) * bushels - positive if option gained value
        // Short: (received - current) * bushels - positive if option lost value (good for seller)
        const premiumDiff = isShort
          ? contract.premium - optionQuote.current_premium
          : optionQuote.current_premium - contract.premium;
        optionPnL = {
          current_premium: optionQuote.current_premium,
          premium_paid: contract.premium,
          per_bushel: premiumDiff,
          total: premiumDiff * contract.bushels,
          quote_symbol: optionQuote.symbol,
          quote_timestamp: optionQuote.timestamp
        };
      }
    }

    return {
      ...contract,
      commodity_name: contract.commodities?.name || 'Unknown',
      buyer_name: contract.buyers?.name || null,
      effective_price: effectivePrice,
      strategy_members: strategyMembers.map(m => ({
        id: m.id,
        option_type: m.option_type,
        position_type: m.position_type,
        strike_price: m.strike_price
      })),
      option_quote: optionQuote,
      option_pnl: optionPnL
    };
  });
}

async function getContractsSummary(cropYear, byPractice = false) {
  const contracts = await getContracts(cropYear);
  const summary = new Map();

  for (const contract of contracts) {
    const key = contract.commodity_id;

    const existing = summary.get(key) || {
      commodity_id: contract.commodity_id,
      // Firm delivery contracts only (CASH, HTA, BASIS)
      contracted_bushels: 0,
      contracted_price_sum: 0,
      // Hedged = Contracted + FUTURES + SHORT CALLs
      hedged_bushels: 0,
      hedged_price_sum: 0,
      // Premium tracking
      premium_paid: 0,      // Long puts - this is a cost
      premium_received: 0,  // Short calls - this is income
      // Bushels covered by long puts (protection)
      protected_bushels: 0,
      by_type: {
        CASH: { count: 0, bushels: 0 },
        FUTURES: { count: 0, bushels: 0 },
        OPTIONS: { count: 0, bushels: 0, long_put: 0, long_call: 0, short_put: 0, short_call: 0 },
        HTA: { count: 0, bushels: 0 },
        BASIS: { count: 0, bushels: 0 }
      }
    };

    existing.by_type[contract.contract_type].count += 1;
    existing.by_type[contract.contract_type].bushels += contract.bushels;

    // Handle different contract types
    if (['CASH', 'HTA', 'BASIS'].includes(contract.contract_type)) {
      // Firm delivery contracts
      existing.contracted_bushels += contract.bushels;
      existing.hedged_bushels += contract.bushels;
      if (contract.effective_price > 0) {
        existing.contracted_price_sum += contract.bushels * contract.effective_price;
        existing.hedged_price_sum += contract.bushels * contract.effective_price;
      }
    } else if (contract.contract_type === 'FUTURES') {
      // Futures count as hedged but not contracted (no forced delivery)
      existing.hedged_bushels += contract.bushels;
      if (contract.effective_price > 0) {
        existing.hedged_price_sum += contract.bushels * contract.effective_price;
      }
    } else if (contract.contract_type === 'OPTIONS') {
      const isShort = contract.position_type === 'SHORT';
      const isPut = contract.option_type === 'PUT';
      const isCall = contract.option_type === 'CALL';

      // Track by option type and position
      if (isPut && !isShort) existing.by_type.OPTIONS.long_put += 1;
      if (isPut && isShort) existing.by_type.OPTIONS.short_put += 1;
      if (isCall && !isShort) existing.by_type.OPTIONS.long_call += 1;
      if (isCall && isShort) existing.by_type.OPTIONS.short_call += 1;

      // SHORT CALL = marketed bushels (you're on the hook)
      if (isCall && isShort) {
        existing.hedged_bushels += contract.bushels;
        // Use strike price as the effective price for short calls
        if (contract.strike_price > 0) {
          existing.hedged_price_sum += contract.bushels * contract.strike_price;
        }
        // Premium received adds to income
        if (contract.premium) {
          existing.premium_received += contract.premium * contract.bushels;
        }
      }

      // LONG PUT = protection (not marketed, but premium is a cost)
      if (isPut && !isShort) {
        existing.protected_bushels += contract.bushels;
        if (contract.premium) {
          existing.premium_paid += contract.premium * contract.bushels;
        }
      }

      // SHORT PUT = obligation to buy (unusual for farmers)
      if (isPut && isShort && contract.premium) {
        existing.premium_received += contract.premium * contract.bushels;
      }

      // LONG CALL = right to buy (unusual for farmers selling grain)
      if (isCall && !isShort && contract.premium) {
        existing.premium_paid += contract.premium * contract.bushels;
      }
    }

    summary.set(key, existing);
  }

  return Array.from(summary.values()).map(s => {
    const netPremium = s.premium_received - s.premium_paid;

    // Weighted avg for contracted only (firm delivery)
    const contractedAvg = s.contracted_bushels > 0
      ? s.contracted_price_sum / s.contracted_bushels
      : null;

    // Weighted avg for hedged (includes futures + short calls)
    const hedgedAvg = s.hedged_bushels > 0
      ? s.hedged_price_sum / s.hedged_bushels
      : null;

    // Adjusted avg includes premium impact
    // Premium paid (puts) is a cost spread across hedged bushels
    // Premium received (short calls) is income spread across hedged bushels
    const hedgedAvgWithPremium = s.hedged_bushels > 0
      ? (s.hedged_price_sum + netPremium) / s.hedged_bushels
      : null;

    return {
      commodity_id: s.commodity_id,
      // Contracted = firm delivery only
      bushels_contracted: s.contracted_bushels,
      weighted_avg_price: contractedAvg,
      // Hedged = contracted + futures + short calls
      bushels_hedged: s.hedged_bushels,
      hedged_avg_price: hedgedAvg,
      hedged_avg_with_premium: hedgedAvgWithPremium,
      // Protection from long puts
      bushels_protected: s.protected_bushels,
      // Premium details
      net_premium: netPremium,
      premium_paid: s.premium_paid,
      premium_received: s.premium_received,
      contracts_by_type: s.by_type
    };
  });
}

async function createContract(contract) {
  const { data, error } = await supabase
    .from('contracts')
    .insert([{
      contract_type: contract.contract_type,
      crop_year: contract.crop_year,
      commodity_id: contract.commodity_id,
      subcategory_id: null,
      buyer_id: contract.buyer_id,
      bushels: contract.bushels,
      bushels_filled: 0,
      cash_price: contract.cash_price,
      futures_price: contract.futures_price,
      basis: contract.basis,
      expected_basis: contract.expected_basis,
      option_type: contract.option_type,
      strike_price: contract.strike_price,
      premium: contract.premium,
      futures_month: contract.futures_month,
      delivery_start: contract.delivery_start,
      delivery_end: contract.delivery_end,
      contract_date: contract.contract_date || new Date().toISOString().split('T')[0],
      contract_number: contract.contract_number,
      status: 'OPEN',
      notes: contract.notes,
      position_type: contract.position_type || null,
      strategy_group_id: contract.strategy_group_id || null,
      strategy_type: contract.strategy_type || null
    }])
    .select()
    .single();

  if (error) { console.error('Error creating contract:', error.message, error.details, error.hint, error.code); return null; }

  // If joining a strategy group, update all contracts in the group with strategy_type
  if (data && contract.strategy_group_id && contract.strategy_type) {
    await supabase
      .from('contracts')
      .update({ strategy_type: contract.strategy_type })
      .eq('strategy_group_id', contract.strategy_group_id);
  }

  return data;
}

async function updateContract(id, updates) {
  const { data, error } = await supabase
    .from('contracts')
    .update(updates)
    .eq('id', id)
    .select()
    .single();

  if (error) { console.error('Error updating contract:', error); return null; }
  return data;
}

async function deleteContract(id) {
  // Get current values for audit log
  const { data: oldRecord } = await supabase.from('contracts').select('*').eq('id', id).single();

  // Soft delete with status change
  const { error } = await supabase
    .from('contracts')
    .update({ status: 'CANCELLED', deleted_at: new Date().toISOString() })
    .eq('id', id);

  if (error) { console.error('Error cancelling contract:', error); return null; }

  // Log audit
  await logAudit('contracts', id, 'DELETE', oldRecord, null);

  return oldRecord; // Return for undo
}

// Restore a soft-deleted contract
async function restoreContract(id) {
  const { data: record } = await supabase.from('contracts').select('*').eq('id', id).single();

  const { error } = await supabase
    .from('contracts')
    .update({ status: 'OPEN', deleted_at: null })
    .eq('id', id);

  if (error) { console.error('Error restoring contract:', error); return false; }

  // Log audit
  await logAudit('contracts', id, 'RESTORE', null, record);

  return true;
}

// Insurance
async function getInsuranceSettings(cropYear) {
  let query = supabase.from('insurance_settings').select('*').order('crop_year', { ascending: false });
  if (cropYear) query = query.eq('crop_year', cropYear);
  const { data, error } = await query;
  if (error) { console.error('Error fetching insurance settings:', error); return []; }
  return data || [];
}

async function upsertInsuranceSetting(setting) {
  let existingQuery = supabase
    .from('insurance_settings')
    .select('id')
    .eq('crop_year', setting.crop_year)
    .eq('commodity_id', setting.commodity_id);

  if (setting.practice_type) {
    existingQuery = existingQuery.eq('practice_type', setting.practice_type);
  } else {
    existingQuery = existingQuery.is('practice_type', null);
  }

  const { data: existing } = await existingQuery.maybeSingle();

  if (existing) {
    const { data, error } = await supabase
      .from('insurance_settings')
      .update({
        coverage_level: setting.coverage_level,
        price_election: setting.price_election,
        policy_type: setting.policy_type,
        notes: setting.notes
      })
      .eq('id', existing.id)
      .select()
      .single();
    if (error) { console.error('Error updating insurance setting:', error); return null; }
    return data;
  } else {
    const { data, error } = await supabase
      .from('insurance_settings')
      .insert([{
        crop_year: setting.crop_year,
        commodity_id: setting.commodity_id,
        subcategory_id: null,
        practice_type: setting.practice_type || null,
        coverage_level: setting.coverage_level || 0.75,
        price_election: setting.price_election || 0,
        policy_type: setting.policy_type || 'RP',
        notes: setting.notes
      }])
      .select()
      .single();
    if (error) { console.error('Error creating insurance setting:', error); return null; }
    return data;
  }
}

// Market Prices - Enhanced with Barchart integration
async function getLatestMarketPrices() {
  // First, get all commodities to build the mapping
  const { data: commodities } = await supabase
    .from('commodities')
    .select('id, name')
    .eq('active', true);
  
  if (!commodities) return {};
  
  const prices = {};
  
  // Try to get Barchart technicals (auto-updated from emails)
  const { data: barchartData, error: barchartError } = await supabase
    .from('barchart_technicals')
    .select('symbol, name, latest_price, rsi_14d, stoch_14d_pct_d, stoch_9d_pct_k, trend_signal, data_timestamp');
  
  // Process Barchart data - find the front month contract for each commodity
  if (barchartData && !barchartError) {
    // Group by commodity prefix to find contracts
    const byPrefix = {};
    for (const row of barchartData) {
      const prefix = row.symbol.substring(0, 2);
      if (!byPrefix[prefix]) byPrefix[prefix] = [];
      byPrefix[prefix].push(row);
    }
    
    // For each commodity, find matching Barchart data
    for (const commodity of commodities) {
      const prefix = BARCHART_COMMODITY_MAP[commodity.name];
      if (!prefix || !byPrefix[prefix]) continue;
      
      // Use the first contract (front month)
      const contracts = byPrefix[prefix];
      if (contracts.length > 0) {
        const front = contracts[0];
        // Barchart grain prices are in CENTS - divide by 100 for dollars
        // e.g., 449.75 cents = $4.4975
        const priceInDollars = front.latest_price / 100;
        prices[commodity.id] = {
          price: priceInDollars,
          source: 'barchart',
          symbol: front.symbol,
          timestamp: front.data_timestamp,
          rsi: front.rsi_14d,
          stoch_d: front.stoch_14d_pct_d,
          stoch_k: front.stoch_9d_pct_k,
          trend: front.trend_signal
        };
      }
    }
  }
  
  // Fall back to manual market_prices for anything not found
  const { data: manualPrices, error: manualError } = await supabase
    .from('market_prices')
    .select('commodity_id, futures_price, updated_at')
    .order('price_date', { ascending: false });
  
  if (manualPrices && !manualError) {
    for (const row of manualPrices) {
      if (!prices[row.commodity_id] && row.futures_price) {
        prices[row.commodity_id] = {
          price: row.futures_price,
          source: 'manual',
          symbol: null,
          timestamp: row.updated_at,
          rsi: null,
          stoch_d: null,
          stoch_k: null,
          trend: null
        };
      }
    }
  }
  
  return prices;
}

// Get option quotes from Barchart technicals
// Parses symbols like "ZCH6|445P" = Corn March 2026 $4.45 Put
async function getOptionQuotes() {
  const { data: barchartData, error } = await supabase
    .from('barchart_technicals')
    .select('symbol, name, latest_price, data_timestamp');

  if (error || !barchartData) return [];

  const options = [];

  for (const row of barchartData) {
    // Check if this is an option (contains | separator)
    if (!row.symbol.includes('|')) continue;

    // Parse symbol: ZCH6|445P or ZCH26|445P
    const [futuresPart, optionPart] = row.symbol.split('|');
    if (!optionPart) continue;

    // Extract commodity prefix (first 2 chars)
    const prefix = futuresPart.substring(0, 2);
    const commodityName = BARCHART_PREFIX_TO_COMMODITY[prefix];
    if (!commodityName) continue;

    // Extract month code and year
    const monthCode = futuresPart.substring(2, 3);
    const yearPart = futuresPart.substring(3);
    const monthInfo = MONTH_CODES[monthCode];
    if (!monthInfo) continue;

    // Year could be 1 digit (6) or 2 digits (26)
    let year = parseInt(yearPart);
    if (year < 100) year += 2000;

    // Parse option part: 445P or 445C
    const optionType = optionPart.slice(-1) === 'P' ? 'PUT' : 'CALL';
    const strikeInCents = parseInt(optionPart.slice(0, -1));
    const strikePrice = strikeInCents / 100; // Convert cents to dollars

    // Premium is in cents, convert to dollars
    const currentPremium = row.latest_price / 100;

    // Build futures month string to match contract format (e.g., "Mar 2026")
    const futuresMonth = `${monthInfo.month} ${year}`;

    options.push({
      symbol: row.symbol,
      name: row.name,
      commodity_name: commodityName,
      prefix: prefix,
      month_code: monthCode,
      futures_month: futuresMonth,
      year: year,
      option_type: optionType,
      strike_price: strikePrice,
      current_premium: currentPremium,
      timestamp: row.data_timestamp
    });
  }

  return options;
}

async function upsertMarketPrice(commodityId, price) {
  const today = new Date().toISOString().split('T')[0];
  
  const { data: existing } = await supabase
    .from('market_prices')
    .select('id')
    .eq('commodity_id', commodityId)
    .eq('price_date', today)
    .maybeSingle();

  if (existing) {
    await supabase.from('market_prices').update({ futures_price: price }).eq('id', existing.id);
  } else {
    await supabase.from('market_prices').insert([{
      commodity_id: commodityId,
      futures_price: price,
      price_date: today
    }]);
  }
  return true;
}

// ============================================================================
// BASIS MANAGEMENT
// ============================================================================

async function getLocationBasis(cropYear = null) {
  let query = supabase
    .from('location_basis')
    .select(`
      id, location_id, commodity_id, crop_year, basis, futures_month, notes, updated_at,
      grain_locations:location_id (id, name, is_basis_reference, basis_reference_location_id, basis_offset),
      commodities:commodity_id (id, name)
    `);
  
  if (cropYear) {
    query = query.eq('crop_year', cropYear);
  }
  
  const { data, error } = await query;
  if (error) { console.error('Error fetching location basis:', error); return []; }
  return data || [];
}

async function upsertLocationBasis(locationId, commodityId, cropYear, basis, futuresMonth = null) {
  const { data: existing } = await supabase
    .from('location_basis')
    .select('id')
    .eq('location_id', locationId)
    .eq('commodity_id', commodityId)
    .eq('crop_year', cropYear)
    .maybeSingle();

  if (existing) {
    const { error } = await supabase
      .from('location_basis')
      .update({ basis, futures_month: futuresMonth, updated_at: new Date().toISOString() })
      .eq('id', existing.id);
    if (error) throw error;
  } else {
    const { error } = await supabase
      .from('location_basis')
      .insert([{ location_id: locationId, commodity_id: commodityId, crop_year: cropYear, basis, futures_month: futuresMonth }]);
    if (error) throw error;
  }
  return true;
}

async function deleteLocationBasis(id) {
  const { error } = await supabase.from('location_basis').delete().eq('id', id);
  if (error) throw error;
  return true;
}

async function setReferenceLocation(locationId) {
  // Clear any existing reference
  await supabase.from('grain_locations').update({ is_basis_reference: false }).eq('is_basis_reference', true);
  // Set new reference
  const { error } = await supabase.from('grain_locations').update({ is_basis_reference: true }).eq('id', locationId);
  if (error) throw error;
  return true;
}

async function setLocationOffset(locationId, referenceLocationId, offset) {
  const { error } = await supabase
    .from('grain_locations')
    .update({ 
      basis_reference_location_id: referenceLocationId, 
      basis_offset: offset 
    })
    .eq('id', locationId);
  if (error) throw error;
  return true;
}

async function clearLocationOffset(locationId) {
  const { error } = await supabase
    .from('grain_locations')
    .update({ basis_reference_location_id: null, basis_offset: 0 })
    .eq('id', locationId);
  if (error) throw error;
  return true;
}

// Storage / Locations
async function getGrainLocations(includeInactive = false) {
  let query = supabase.from('grain_locations').select('*').order('sort_order');
  if (!includeInactive) query = query.eq('active', true);
  const { data: locations, error } = await query;
  if (error) { console.error('Error fetching grain locations:', error); return []; }
  if (!locations?.length) return [];

  const { data: links } = await supabase.from('grain_location_buyers').select('location_id, buyer_id');
  const { data: buyers } = await supabase.from('buyers').select('id, name').eq('active', true);
  const buyerMap = new Map((buyers || []).map(b => [b.id, b.name]));

  return locations.map(loc => ({
    ...loc,
    buyers: (links || [])
      .filter(l => l.location_id === loc.id)
      .map(l => ({ buyer_id: l.buyer_id, buyer_name: buyerMap.get(l.buyer_id) || 'Unknown' }))
  }));
}

async function createGrainLocation(location) {
  const { data: maxData } = await supabase
    .from('grain_locations')
    .select('sort_order')
    .order('sort_order', { ascending: false })
    .limit(1)
    .single();

  const { data, error } = await supabase
    .from('grain_locations')
    .insert([{
      name: location.name,
      location_type: location.location_type,
      is_storage: location.is_storage,
      is_delivery: location.is_delivery,
      notes: location.notes || null,
      active: true,
      sort_order: (maxData?.sort_order || 0) + 1
    }])
    .select()
    .single();

  if (error) { console.error('Error creating grain location:', error); return null; }
  return data;
}

async function updateGrainLocation(id, updates) {
  const { data, error } = await supabase
    .from('grain_locations')
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq('id', id)
    .select()
    .single();
  if (error) { console.error('Error updating grain location:', error); return null; }
  return data;
}

async function deleteGrainLocation(id) {
  await supabase.from('grain_location_buyers').delete().eq('location_id', id);
  const { error } = await supabase.from('grain_locations').delete().eq('id', id);
  if (error) { console.error('Error deleting grain location:', error); return false; }
  return true;
}

async function toggleGrainLocationActive(id, active) {
  const { error } = await supabase
    .from('grain_locations')
    .update({ active, updated_at: new Date().toISOString() })
    .eq('id', id);
  if (error) { console.error('Error toggling grain location active:', error); return false; }
  return true;
}

async function setLocationBuyers(locationId, buyerIds) {
  await supabase.from('grain_location_buyers').delete().eq('location_id', locationId);
  if (buyerIds.length === 0) return true;
  const { error } = await supabase
    .from('grain_location_buyers')
    .insert(buyerIds.map(buyerId => ({ location_id: locationId, buyer_id: buyerId })));
  if (error) { console.error('Error setting location buyers:', error); return false; }
  return true;
}

async function getStorageLocations() {
  const { data, error } = await supabase
    .from('grain_locations')
    .select('*')
    .eq('active', true)
    .eq('is_storage', true)
    .order('sort_order');
  if (error) return [];
  return data || [];
}

async function getDeliveryLocations() {
  const { data, error } = await supabase
    .from('grain_locations')
    .select('*')
    .eq('active', true)
    .eq('is_delivery', true)
    .order('sort_order');
  if (error) return [];
  return data || [];
}

// Inventory
async function getInventory(cropYear) {
  let query = supabase
    .from('grain_inventory')
    .select(`
      id, location_id, commodity_id, crop_year, bushels,
      grain_locations:location_id (name, location_type),
      commodities:commodity_id (name)
    `);
  
  if (cropYear) query = query.eq('crop_year', cropYear);
  const { data, error } = await query;
  if (error) { console.error('Error fetching inventory:', error); return []; }

  return (data || []).map(row => ({
    id: row.id,
    location_id: row.location_id,
    location_name: row.grain_locations?.name || 'Unknown',
    location_type: row.grain_locations?.location_type || 'COMMERCIAL',
    commodity_id: row.commodity_id,
    commodity_name: row.commodities?.name || 'Unknown',
    crop_year: row.crop_year,
    bushels: row.bushels
  }));
}

async function addToInventory(locationId, commodityId, cropYear, bushels) {
  const { data: existing } = await supabase
    .from('grain_inventory')
    .select('id, bushels')
    .eq('location_id', locationId)
    .eq('commodity_id', commodityId)
    .eq('crop_year', cropYear)
    .maybeSingle();

  if (existing) {
    const { error } = await supabase
      .from('grain_inventory')
      .update({ bushels: existing.bushels + bushels })
      .eq('id', existing.id);
    if (error) return false;
  } else {
    const { error } = await supabase
      .from('grain_inventory')
      .insert([{ location_id: locationId, commodity_id: commodityId, crop_year: cropYear, bushels }]);
    if (error) return false;
  }
  return true;
}

async function removeFromInventory(locationId, commodityId, cropYear, bushels) {
  const { data: existing } = await supabase
    .from('grain_inventory')
    .select('id, bushels')
    .eq('location_id', locationId)
    .eq('commodity_id', commodityId)
    .eq('crop_year', cropYear)
    .maybeSingle();

  if (!existing || existing.bushels < bushels) return false;

  const newBushels = existing.bushels - bushels;
  if (newBushels <= 0) {
    await supabase.from('grain_inventory').delete().eq('id', existing.id);
  } else {
    await supabase.from('grain_inventory').update({ bushels: newBushels }).eq('id', existing.id);
  }
  return true;
}

// ============================================================================
// INVENTORY TRANSACTIONS (v1.7.0)
// Full audit trail for all inventory movements
// ============================================================================

async function getInventoryTransactions(locationId, commodityId, cropYear) {
  let query = supabase
    .from('inventory_transactions')
    .select(`
      *,
      grain_locations:location_id (name),
      commodities:commodity_id (name)
    `)
    .order('transaction_date', { ascending: false })
    .order('created_at', { ascending: false });
  
  if (locationId) query = query.eq('location_id', locationId);
  if (commodityId) query = query.eq('commodity_id', commodityId);
  if (cropYear) query = query.eq('crop_year', cropYear);
  
  const { data, error } = await query;
  if (error) { console.error('Error fetching inventory transactions:', error); return []; }
  
  return (data || []).map(row => ({
    ...row,
    location_name: row.grain_locations?.name || 'Unknown',
    commodity_name: row.commodities?.name || 'Unknown'
  }));
}

async function createInventoryTransaction(transaction) {
  const { data, error } = await supabase
    .from('inventory_transactions')
    .insert([{
      location_id: transaction.location_id,
      commodity_id: transaction.commodity_id,
      crop_year: transaction.crop_year,
      transaction_type: transaction.transaction_type,
      bushels: transaction.bushels,
      transaction_date: transaction.transaction_date || new Date().toISOString().split('T')[0],
      counterparty: transaction.counterparty || null,
      reason: transaction.reason || null,
      ticket_numbers: transaction.ticket_numbers || null,
      linked_contract_id: transaction.linked_contract_id || null,
      linked_transaction_id: transaction.linked_transaction_id || null,
      import_id: transaction.import_id || null,
      notes: transaction.notes || null
    }])
    .select()
    .single();
  
  if (error) { console.error('Error creating inventory transaction:', error); return null; }
  return data;
}

// Combined function: update inventory balance AND create transaction record
async function recordInventoryChange(locationId, commodityId, cropYear, bushels, transactionType, options = {}) {
  // 1. Update the balance in grain_inventory
  if (bushels > 0) {
    await addToInventory(locationId, commodityId, cropYear, bushels);
  } else if (bushels < 0) {
    const success = await removeFromInventory(locationId, commodityId, cropYear, Math.abs(bushels));
    if (!success) {
      console.error('Failed to remove from inventory - insufficient balance');
      return null;
    }
  }
  
  // 2. Create the audit trail transaction
  const transaction = await createInventoryTransaction({
    location_id: locationId,
    commodity_id: commodityId,
    crop_year: cropYear,
    transaction_type: transactionType,
    bushels: bushels,
    transaction_date: options.transaction_date,
    counterparty: options.counterparty,
    reason: options.reason,
    ticket_numbers: options.ticket_numbers,
    linked_contract_id: options.linked_contract_id,
    linked_transaction_id: options.linked_transaction_id,
    import_id: options.import_id,
    notes: options.notes
  });
  
  return transaction;
}

// ============================================================================
// ELEVATOR LOCATION MAPPINGS (v1.7.0)
// Map elevator names from POY reports to GrainTrack locations
// ============================================================================

async function getElevatorMappings() {
  const { data, error } = await supabase
    .from('elevator_location_mappings')
    .select(`
      *,
      grain_locations:location_id (id, name)
    `)
    .order('elevator_name');
  
  if (error) { console.error('Error fetching elevator mappings:', error); return []; }
  return data || [];
}

async function createElevatorMapping(elevatorName, locationId) {
  const { data, error } = await supabase
    .from('elevator_location_mappings')
    .insert([{ elevator_name: elevatorName, location_id: locationId }])
    .select()
    .single();
  
  if (error) { console.error('Error creating elevator mapping:', error); return null; }
  return data;
}

async function updateElevatorMapping(id, locationId) {
  const { data, error } = await supabase
    .from('elevator_location_mappings')
    .update({ location_id: locationId })
    .eq('id', id)
    .select()
    .single();
  
  if (error) { console.error('Error updating elevator mapping:', error); return null; }
  return data;
}

// ============================================================================
// POY IMPORTS (v1.7.0)
// Track import batches and prevent duplicate tickets
// ============================================================================

async function createPoyImport(importData) {
  const { data, error } = await supabase
    .from('poy_imports')
    .insert([{
      file_name: importData.file_name,
      crop_year: importData.crop_year,
      producer_name: importData.producer_name,
      total_bushels_imported: importData.total_bushels_imported,
      total_tickets_imported: importData.total_tickets_imported,
      tickets_skipped: importData.tickets_skipped || 0,
      commodities_imported: importData.commodities_imported,
      locations_imported: importData.locations_imported,
      raw_response: importData.raw_response
    }])
    .select()
    .single();
  
  if (error) { console.error('Error creating POY import:', error); return null; }
  return data;
}

async function getPoyImports() {
  const { data, error } = await supabase
    .from('poy_imports')
    .select('*')
    .order('import_date', { ascending: false });
  
  if (error) { console.error('Error fetching POY imports:', error); return []; }
  return data || [];
}

async function recordImportedTicket(ticket) {
  const { data, error } = await supabase
    .from('imported_tickets')
    .insert([{
      ticket_number: ticket.ticket_number,
      import_id: ticket.import_id,
      delivery_date: ticket.delivery_date,
      commodity_id: ticket.commodity_id,
      location_id: ticket.location_id,
      bushels: ticket.bushels,
      elevator_name: ticket.elevator_name
    }])
    .select()
    .single();
  
  if (error) { 
    // Likely duplicate - ignore
    if (error.code === '23505') return null; // unique violation
    console.error('Error recording imported ticket:', error); 
    return null; 
  }
  return data;
}

async function checkExistingTickets(ticketNumbers) {
  if (!ticketNumbers || ticketNumbers.length === 0) return [];
  
  const { data, error } = await supabase
    .from('imported_tickets')
    .select('ticket_number')
    .in('ticket_number', ticketNumbers);
  
  if (error) { console.error('Error checking existing tickets:', error); return []; }
  return (data || []).map(t => t.ticket_number);
}

// ============================================================================
// CLAUDE API FOR POY PARSING (v1.7.0)
// ============================================================================

const POY_EXTRACTION_PROMPT = `Extract grain delivery data from this Proof of Yield document.

Return ONLY valid JSON (no markdown, no explanation, no code blocks) in this exact format:
{
  "crop_year": 2025,
  "producer_name": "NAME FROM DOCUMENT",
  "deliveries": [
    {
      "ticket_number": "BI 110366",
      "date": "2025-10-01",
      "commodity": "Corn",
      "location": "Groveland",
      "your_bushels": 510.89
    }
  ],
  "summary_by_location": [
    {
      "commodity": "Corn",
      "location": "Groveland",
      "total_your_bushels": 39452.75,
      "ticket_count": 77
    }
  ],
  "totals_by_commodity": {
    "Corn": 57357.30,
    "Soybeans": 20590.25,
    "Milo": 10985.97
  }
}

Important rules:
1. Extract EVERY ticket number for duplicate detection
2. Use "Customer Portion" bushels (producer's share after landlord splits)
3. Location is from section headers like "CORN @ GROVELAND" â†’ "Groveland"
4. Dates in ISO format (YYYY-MM-DD)
5. Normalize commodity names: "Corn", "Soybeans", "Milo", "Wheat"
6. Return ONLY the JSON, nothing else`;

async function parsePoYWithClaude(fileBase64, mimeType) {
  try {
    const response = await fetch('/portal/grain/api/claude-proxy.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 32768,
        messages: [{
          role: 'user',
          content: [
            {
              type: 'document',
              source: {
                type: 'base64',
                media_type: mimeType,
                data: fileBase64
              }
            },
            {
              type: 'text',
              text: POY_EXTRACTION_PROMPT
            }
          ]
        }]
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API request failed: ${response.status} - ${errorText}`);
    }
    
    const data = await response.json();
    
    if (data.error) {
      throw new Error(data.error.message || 'API error');
    }
    
    // Extract the text content from Claude's response
    const textContent = data.content?.find(c => c.type === 'text')?.text;
    if (!textContent) {
      throw new Error('No text content in response');
    }
    
    // Parse the JSON from Claude's response
    // Clean up any markdown code blocks if present
    let jsonStr = textContent.trim();

    // Remove markdown code blocks
    if (jsonStr.startsWith('```')) {
      jsonStr = jsonStr.replace(/^```json?\n?/, '').replace(/\n?```$/, '');
    }

    // Try to extract just the JSON object if there's extra text
    const jsonMatch = jsonStr.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      jsonStr = jsonMatch[0];
    }

    // Fix common JSON issues: trailing commas before ] or }
    jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');

    // Fix unquoted property names (rare but possible)
    jsonStr = jsonStr.replace(/([{,]\s*)(\w+)(\s*:)/g, '$1"$2"$3');

    // Try parsing, with detailed error on failure
    try {
      const parsed = JSON.parse(jsonStr);
      return { success: true, data: parsed };
    } catch (parseError) {
      // Extract position from error message
      const posMatch = parseError.message.match(/position (\d+)/);
      if (posMatch) {
        const pos = parseInt(posMatch[1]);
        const start = Math.max(0, pos - 100);
        const end = Math.min(jsonStr.length, pos + 100);
        const context = jsonStr.substring(start, end);
        console.error('JSON error near position', pos, ':', context);
        console.error('Full response length:', jsonStr.length);

        // Log the raw response for debugging
        console.log('Raw Claude response (first 2000 chars):', textContent.substring(0, 2000));
      }
      throw parseError;
    }

  } catch (error) {
    console.error('Error parsing POY with Claude:', error);
    return { success: false, error: error.message };
  }
}

function fileToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = reader.result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// Dashboard data
async function getDashboardData(cropYear, detailMode = 'combined') {
  const byPractice = detailMode === 'detailed';
  
  const [commodities, productionSummary, contractsSummary, insuranceSettings, marketPrices] = 
    await Promise.all([
      getCommodities(),
      getProductionSummary(cropYear, byPractice),
      getContractsSummary(cropYear),
      getInsuranceSettings(cropYear),
      getLatestMarketPrices()
    ]);

  const commodityProgress = [];

  for (const commodity of commodities) {
    // Find matching production entries
    const productions = productionSummary.filter(p => p.commodity_id === commodity.id);
    const contracts = contractsSummary.find(c => c.commodity_id === commodity.id);
    const insurance = insuranceSettings.find(i => i.commodity_id === commodity.id && !i.practice_type);
    const marketData = marketPrices[commodity.id] || null;
    const currentMarket = marketData?.price || null;

    // If byPractice is true and there are multiple production entries, show them separately
    if (byPractice && productions.length > 0) {
      for (const prod of productions) {
        let displayName = commodity.name;
        if (prod.is_irrigated) displayName += ' IR';
        if (prod.is_double_crop) displayName += ' (DC)';
        
        // Try to find practice-specific insurance
        let practiceInsurance = insurance;
        if (prod.is_double_crop) {
          practiceInsurance = insuranceSettings.find(i => 
            i.commodity_id === commodity.id && i.practice_type === 'DC'
          ) || insuranceSettings.find(i => 
            i.commodity_id === commodity.id && i.practice_type === 'FS'
          ) || insurance;
        } else if (prod.is_irrigated) {
          practiceInsurance = insuranceSettings.find(i => 
            i.commodity_id === commodity.id && i.practice_type === 'IR'
          ) || insuranceSettings.find(i => 
            i.commodity_id === commodity.id && i.practice_type === 'DL'
          ) || insurance;
        }

        const expectedProduction = prod.expected_production || 0;
        const actualProduction = prod.actual_production || null;
        
        // Contracts are still at commodity level
        const totalProductions = productions.reduce((sum, p) => sum + (p.expected_production || 0), 0);
        const bushelsSold = totalProductions > 0 
          ? Math.round((expectedProduction / totalProductions) * (contracts?.bushels_contracted || 0))
          : 0;
        
        const coverageLevel = practiceInsurance?.coverage_level || 0.75;
        const insuranceProduction = expectedProduction * coverageLevel;

        const percentExpected = expectedProduction > 0 ? Math.min((bushelsSold / expectedProduction) * 100, 100) : 0;
        const percentActual = actualProduction !== null && actualProduction > 0 
          ? Math.min((bushelsSold / actualProduction) * 100, 100) : null;
        const percentInsurance = insuranceProduction > 0 
          ? Math.min((bushelsSold / insuranceProduction) * 100, 100) : 0;

        // Contracted = firm delivery only
        const weightedAvg = contracts?.weighted_avg_price || null;
        // Hedged = contracted + futures + short calls
        const bushelsHedged = totalProductions > 0
          ? Math.round((expectedProduction / totalProductions) * (contracts?.bushels_hedged || 0))
          : 0;
        const hedgedAvg = contracts?.hedged_avg_with_premium || null;
        const bushelsProtected = totalProductions > 0
          ? Math.round((expectedProduction / totalProductions) * (contracts?.bushels_protected || 0))
          : 0;

        let blendedAvg = null;
        if (expectedProduction > 0 && (weightedAvg || currentMarket)) {
          const unsoldBu = Math.max(0, expectedProduction - bushelsSold);
          blendedAvg = ((bushelsSold * (weightedAvg || 0)) + (unsoldBu * (currentMarket || 0))) / expectedProduction;
        }
        let blendedAvgHedged = null;
        if (expectedProduction > 0 && (hedgedAvg || currentMarket)) {
          const unsoldBu = Math.max(0, expectedProduction - bushelsHedged);
          blendedAvgHedged = ((bushelsHedged * (hedgedAvg || 0)) + (unsoldBu * (currentMarket || 0))) / expectedProduction;
        }

        const percentHedged = expectedProduction > 0 ? Math.min((bushelsHedged / expectedProduction) * 100, 100) : 0;

        commodityProgress.push({
          commodity_id: commodity.id,
          commodity_name: commodity.name,
          is_irrigated: prod.is_irrigated,
          is_double_crop: prod.is_double_crop,
          display_name: displayName,
          crop_year: cropYear,
          expected_production: expectedProduction,
          actual_production: actualProduction,
          insurance_production: insuranceProduction,
          // Contracted (firm delivery)
          bushels_contracted: bushelsSold,
          percent_expected: percentExpected,
          percent_actual: percentActual,
          percent_insurance: percentInsurance,
          weighted_avg_price: weightedAvg,
          blended_avg_price: blendedAvg,
          // Hedged (includes futures + short calls)
          bushels_hedged: bushelsHedged,
          percent_hedged: percentHedged,
          hedged_avg_price: hedgedAvg,
          blended_avg_hedged: blendedAvgHedged,
          // Protected (long puts)
          bushels_protected: bushelsProtected,
          // Premium
          net_premium: contracts?.net_premium || 0,
          premium_paid: contracts?.premium_paid || 0,
          premium_received: contracts?.premium_received || 0,
          // Market data
          current_market_price: currentMarket,
          market_source: marketData?.source || null,
          market_symbol: marketData?.symbol || null,
          market_timestamp: marketData?.timestamp || null,
          market_rsi: marketData?.rsi || null,
          market_stoch_d: marketData?.stoch_d || null,
          market_stoch_k: marketData?.stoch_k || null,
          market_trend: marketData?.trend || null,
          contracts_by_type: contracts?.contracts_by_type || {
            CASH: { count: 0, bushels: 0 },
            FUTURES: { count: 0, bushels: 0 },
            OPTIONS: { count: 0, bushels: 0, long_put: 0, long_call: 0, short_put: 0, short_call: 0 },
            HTA: { count: 0, bushels: 0 },
            BASIS: { count: 0, bushels: 0 }
          }
        });
      }
    } else {
      // Combined view - one row per commodity
      const production = productions.reduce((sum, p) => ({
        expected: (sum.expected || 0) + (p.expected_production || 0),
        actual: p.actual_production !== null ? (sum.actual || 0) + p.actual_production : sum.actual
      }), { expected: 0, actual: null });

      const expectedProduction = production.expected || 0;
      const actualProduction = production.actual;
      const bushelsSold = contracts?.bushels_contracted || 0;
      
      const coverageLevel = insurance?.coverage_level || 0.75;
      const insuranceProduction = expectedProduction * coverageLevel;

      const percentExpected = expectedProduction > 0 ? Math.min((bushelsSold / expectedProduction) * 100, 100) : 0;
      const percentActual = actualProduction !== null && actualProduction > 0 
        ? Math.min((bushelsSold / actualProduction) * 100, 100) : null;
      const percentInsurance = insuranceProduction > 0 
        ? Math.min((bushelsSold / insuranceProduction) * 100, 100) : 0;

      // Contracted = firm delivery only
      const weightedAvg = contracts?.weighted_avg_price || null;
      // Hedged = contracted + futures + short calls
      const bushelsHedged = contracts?.bushels_hedged || 0;
      const hedgedAvg = contracts?.hedged_avg_with_premium || null;
      const bushelsProtected = contracts?.bushels_protected || 0;

      let blendedAvg = null;
      if (expectedProduction > 0 && (weightedAvg || currentMarket)) {
        const unsoldBu = Math.max(0, expectedProduction - bushelsSold);
        blendedAvg = ((bushelsSold * (weightedAvg || 0)) + (unsoldBu * (currentMarket || 0))) / expectedProduction;
      }
      let blendedAvgHedged = null;
      if (expectedProduction > 0 && (hedgedAvg || currentMarket)) {
        const unsoldBu = Math.max(0, expectedProduction - bushelsHedged);
        blendedAvgHedged = ((bushelsHedged * (hedgedAvg || 0)) + (unsoldBu * (currentMarket || 0))) / expectedProduction;
      }

      const percentHedged = expectedProduction > 0 ? Math.min((bushelsHedged / expectedProduction) * 100, 100) : 0;

      if (expectedProduction > 0 || bushelsSold > 0 || bushelsHedged > 0) {
        commodityProgress.push({
          commodity_id: commodity.id,
          commodity_name: commodity.name,
          is_irrigated: null,
          is_double_crop: null,
          display_name: commodity.name,
          crop_year: cropYear,
          expected_production: expectedProduction,
          actual_production: actualProduction,
          insurance_production: insuranceProduction,
          // Contracted (firm delivery)
          bushels_contracted: bushelsSold,
          percent_expected: percentExpected,
          percent_actual: percentActual,
          percent_insurance: percentInsurance,
          weighted_avg_price: weightedAvg,
          blended_avg_price: blendedAvg,
          // Hedged (includes futures + short calls)
          bushels_hedged: bushelsHedged,
          percent_hedged: percentHedged,
          hedged_avg_price: hedgedAvg,
          blended_avg_hedged: blendedAvgHedged,
          // Protected (long puts)
          bushels_protected: bushelsProtected,
          // Premium
          net_premium: contracts?.net_premium || 0,
          premium_paid: contracts?.premium_paid || 0,
          premium_received: contracts?.premium_received || 0,
          // Market data
          current_market_price: currentMarket,
          market_source: marketData?.source || null,
          market_symbol: marketData?.symbol || null,
          market_timestamp: marketData?.timestamp || null,
          market_rsi: marketData?.rsi || null,
          market_stoch_d: marketData?.stoch_d || null,
          market_stoch_k: marketData?.stoch_k || null,
          market_trend: marketData?.trend || null,
          contracts_by_type: contracts?.contracts_by_type || {
            CASH: { count: 0, bushels: 0 },
            FUTURES: { count: 0, bushels: 0 },
            OPTIONS: { count: 0, bushels: 0, long_put: 0, long_call: 0, short_put: 0, short_call: 0 },
            HTA: { count: 0, bushels: 0 },
            BASIS: { count: 0, bushels: 0 }
          }
        });
      }
    }
  }

  const totalExpected = commodityProgress.reduce((sum, c) => sum + c.expected_production, 0);
  const totalContracted = commodityProgress.reduce((sum, c) => sum + c.bushels_contracted, 0);
  const totalPercent = totalExpected > 0 ? (totalContracted / totalExpected) * 100 : 0;

  return {
    crop_year: cropYear,
    commodities: commodityProgress,
    total_expected: totalExpected,
    total_contracted: totalContracted,
    total_percent: totalPercent,
    market_prices: marketPrices
  };
}

// ============================================================================
// PAGES
// ============================================================================

// Navigation items
const navItems = [
  { id: 'dashboard', label: 'Dashboard', icon: 'layout-dashboard' },
  { id: 'add-sale', label: 'Add Sale', icon: 'plus-circle' },
  { id: 'contracts', label: 'Contracts', icon: 'file-text' },
  { id: 'production', label: 'Production', icon: 'wheat' },
  { id: 'inventory', label: 'Inventory', icon: 'package' },
  { id: 'insurance', label: 'Insurance', icon: 'shield' },
  { id: 'buyers', label: 'Buyers', icon: 'building-2' },
  { id: 'storage', label: 'Storage', icon: 'warehouse' },
  { id: 'basis', label: 'Basis', icon: 'trending-up' },
  { id: 'settings', label: 'Settings', icon: 'settings' }
];

// Dashboard Page
function DashboardPage({ cropYear, onYearChange }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [viewMode, setViewMode] = useState(() => localStorage.getItem('graintrack_viewmode') || 'expected');
  const [detailMode, setDetailMode] = useState(() => localStorage.getItem('graintrack_detailmode') || 'combined');
  const [marketingView, setMarketingView] = useState(() => localStorage.getItem('graintrack_marketingview') || 'contracted');
  const [editingPrice, setEditingPrice] = useState(null);
  const [tempPrice, setTempPrice] = useState('');

  const currentYear = new Date().getFullYear();
  const cropYears = [currentYear - 1, currentYear, currentYear + 1, currentYear + 2];

  const commodityColors = {
    'Corn': { bg: 'bg-amber-100', fill: 'bg-amber-500', text: 'text-amber-700' },
    'Soybeans': { bg: 'bg-emerald-100', fill: 'bg-emerald-500', text: 'text-emerald-700' },
    'Wheat': { bg: 'bg-violet-100', fill: 'bg-violet-500', text: 'text-violet-700' },
    'Milo': { bg: 'bg-red-100', fill: 'bg-red-500', text: 'text-red-700' }
  };
  const defaultColors = { bg: 'bg-gray-100', fill: 'bg-gray-500', text: 'text-gray-700' };

  const loadData = async () => {
    setLoading(true);
    const dashboardData = await getDashboardData(cropYear, detailMode);
    setData(dashboardData);
    setLoading(false);
  };

  useEffect(() => { loadData(); }, [cropYear, detailMode]);
  useEffect(() => { localStorage.setItem('graintrack_viewmode', viewMode); }, [viewMode]);
  useEffect(() => { localStorage.setItem('graintrack_detailmode', detailMode); }, [detailMode]);
  useEffect(() => { localStorage.setItem('graintrack_marketingview', marketingView); }, [marketingView]);

  const handleSavePrice = async (commodityId) => {
    const price = parseFloat(tempPrice);
    if (!isNaN(price) && price >= 0) {
      await upsertMarketPrice(commodityId, price);
      await loadData();
    }
    setEditingPrice(null);
    setTempPrice('');
  };

  const getProgressPercent = (c) => {
    switch (viewMode) {
      case 'actual': return c.percent_actual ?? c.percent_expected;
      case 'insurance': return c.percent_insurance;
      default: return c.percent_expected;
    }
  };

  const formatNumber = (n) => n == null ? '-' : n.toLocaleString('en-US', { maximumFractionDigits: 0 });
  const formatPrice = (n) => n == null || n === 0 ? '-' : '$' + n.toFixed(2);
  const formatPercent = (n) => n == null ? '-' : n.toFixed(1) + '%';

  if (loading) {
    return <div className="flex items-center justify-center h-64"><Icon name="refresh-cw" className="animate-spin text-amber-600" size={32} /></div>;
  }

  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
          <p className="text-sm text-gray-500 mt-1">Marketing progress overview</p>
        </div>
        <div className="flex items-center gap-3 flex-wrap">
          <select value={cropYear} onChange={(e) => onYearChange(parseInt(e.target.value))}
            className="px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium focus:ring-2 focus:ring-amber-500">
            {cropYears.map(year => <option key={year} value={year}>{year} Crop Year</option>)}
          </select>
          <div className="flex rounded-lg border border-gray-200 overflow-hidden">
            {['expected', 'actual', 'insurance'].map(mode => (
              <button key={mode} onClick={() => setViewMode(mode)}
                className={`px-3 py-1.5 text-sm font-medium transition-colors ${
                  viewMode === mode ? 'bg-amber-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-50'
                } ${mode !== 'expected' ? 'border-l border-gray-200' : ''}`}>
                {mode === 'expected' ? 'Expected' : mode === 'actual' ? 'Actual' : 'Insurance'}
              </button>
            ))}
          </div>
          <div className="flex rounded-lg border border-gray-200 overflow-hidden">
            <button onClick={() => setDetailMode('combined')}
              className={`px-3 py-1.5 text-sm font-medium transition-colors ${
                detailMode === 'combined' ? 'bg-blue-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-50'}`}>
              Combined
            </button>
            <button onClick={() => setDetailMode('detailed')}
              className={`px-3 py-1.5 text-sm font-medium transition-colors border-l border-gray-200 ${
                detailMode === 'detailed' ? 'bg-blue-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-50'}`}>
              By Practice
            </button>
          </div>
          <div className="flex rounded-lg border border-gray-200 overflow-hidden">
            <button onClick={() => setMarketingView('contracted')}
              className={`px-3 py-1.5 text-sm font-medium transition-colors ${
                marketingView === 'contracted' ? 'bg-green-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-50'}`}
              title="Firm delivery contracts only (Cash, HTA, Basis)">
              Contracted
            </button>
            <button onClick={() => setMarketingView('hedged')}
              className={`px-3 py-1.5 text-sm font-medium transition-colors border-l border-gray-200 ${
                marketingView === 'hedged' ? 'bg-green-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-50'}`}
              title="Includes Futures + Sold Calls">
              Hedged
            </button>
          </div>
        </div>
      </div>

      {/* Summary */}
      {(() => {
        const totalMarketed = marketingView === 'hedged'
          ? (data?.commodities || []).reduce((sum, c) => sum + (c.bushels_hedged || 0), 0)
          : data?.total_contracted || 0;
        const totalPercent = data?.total_expected > 0 ? (totalMarketed / data.total_expected) * 100 : 0;
        const totalNetPremium = (data?.commodities || []).reduce((sum, c) => sum + (c.net_premium || 0), 0);
        const totalProtected = (data?.commodities || []).reduce((sum, c) => sum + (c.bushels_protected || 0), 0);

        return (
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-amber-100 rounded-lg"><Icon name="trending-up" size={20} className="text-amber-600" /></div>
                <div>
                  <p className="text-sm text-gray-500">Total Expected</p>
                  <p className="text-xl font-bold text-gray-900">{formatNumber(data?.total_expected)} bu</p>
                </div>
              </div>
            </div>
            <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-green-100 rounded-lg"><Icon name="check-circle" size={20} className="text-green-600" /></div>
                <div>
                  <p className="text-sm text-gray-500">{marketingView === 'hedged' ? 'Total Hedged' : 'Total Contracted'}</p>
                  <p className="text-xl font-bold text-gray-900">{formatNumber(totalMarketed)} bu</p>
                  {marketingView === 'hedged' && totalProtected > 0 && (
                    <p className="text-xs text-gray-400">{formatNumber(totalProtected)} bu protected</p>
                  )}
                </div>
              </div>
            </div>
            <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-blue-100 rounded-lg"><Icon name="bar-chart-3" size={20} className="text-blue-600" /></div>
                <div>
                  <p className="text-sm text-gray-500">{marketingView === 'hedged' ? 'Overall Hedged' : 'Overall Sold'}</p>
                  <p className="text-xl font-bold text-gray-900">{formatPercent(totalPercent)}</p>
                </div>
              </div>
            </div>
            <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
              <div className="flex items-center gap-3">
                <div className={`p-2 rounded-lg ${totalNetPremium >= 0 ? 'bg-green-100' : 'bg-red-100'}`}>
                  <Icon name="dollar-sign" size={20} className={totalNetPremium >= 0 ? 'text-green-600' : 'text-red-600'} />
                </div>
                <div>
                  <p className="text-sm text-gray-500">Net Premium</p>
                  <p className={`text-xl font-bold ${totalNetPremium >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                    {totalNetPremium >= 0 ? '+' : ''}{formatPrice(totalNetPremium)}
                  </p>
                </div>
              </div>
            </div>
          </div>
        );
      })()}

      {/* Commodity Cards */}
      <div className="space-y-4">
        {(data?.commodities || []).map(c => {
          const colors = commodityColors[c.commodity_name] || defaultColors;
          const isHedgedView = marketingView === 'hedged';
          const displayBushels = isHedgedView ? c.bushels_hedged : c.bushels_contracted;
          const displayAvg = isHedgedView ? c.hedged_avg_price : c.weighted_avg_price;
          const displayBlended = isHedgedView ? c.blended_avg_hedged : c.blended_avg_price;
          const displayPercent = isHedgedView ? c.percent_hedged : getProgressPercent(c);

          return (
            <div key={`${c.commodity_id}-${c.is_irrigated}-${c.is_double_crop}`} className="bg-white rounded-xl shadow-sm border border-gray-200 p-5">
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-3">
                  <span className={`text-lg font-bold ${colors.text}`}>{c.display_name}</span>
                  <span className="text-sm text-gray-500">{formatNumber(displayBushels)} / {formatNumber(c.expected_production)} bu</span>
                  {isHedgedView && c.bushels_protected > 0 && (
                    <span className="text-xs px-2 py-0.5 bg-blue-100 text-blue-700 rounded-full">
                      {formatNumber(c.bushels_protected)} bu protected
                    </span>
                  )}
                </div>
                <div className="flex items-center gap-4 text-sm">
                  <div className="text-right">
                    <p className="text-gray-500">{isHedgedView ? 'Hedged Avg' : 'Weighted Avg'}</p>
                    <p className="font-semibold">{formatPrice(displayAvg)}</p>
                  </div>
                  <div className="text-right">
                    <p className="text-gray-500">Blended</p>
                    <p className="font-semibold">{formatPrice(displayBlended)}</p>
                  </div>
                  {c.net_premium !== 0 && (
                    <div className="text-right">
                      <p className="text-gray-500">Net Prem</p>
                      <p className={`font-semibold ${c.net_premium >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                        {c.net_premium >= 0 ? '+' : ''}{formatPrice(c.net_premium)}
                      </p>
                    </div>
                  )}
                  <div className="text-right">
                    <p className="text-gray-500 flex items-center justify-end gap-1">
                      Market
                      {c.market_source === 'barchart' && (
                        <span className="text-green-500 text-xs" title={`From Barchart: ${c.market_symbol}`}>*Â</span>
                      )}
                    </p>
                    {editingPrice === c.commodity_id ? (
                      <div className="flex items-center gap-1">
                        <input type="number" step="0.01" value={tempPrice} onChange={(e) => setTempPrice(e.target.value)}
                          className="w-16 px-1 py-0.5 text-right border rounded text-sm" autoFocus />
                        <button onClick={() => handleSavePrice(c.commodity_id)} className="text-green-600"><Icon name="check" size={14} /></button>
                        <button onClick={() => { setEditingPrice(null); setTempPrice(''); }} className="text-gray-400"><Icon name="x" size={14} /></button>
                      </div>
                    ) : (
                      <div>
                        <p className="font-semibold cursor-pointer hover:text-amber-600" 
                          onClick={() => { setEditingPrice(c.commodity_id); setTempPrice(c.current_market_price?.toString() || ''); }}>
                          {formatPrice(c.current_market_price)}
                        </p>
                        {c.market_source === 'barchart' && c.market_timestamp && (
                          <p className="text-xs text-gray-400">
                            {new Date(c.market_timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                          </p>
                        )}
                      </div>
                    )}
                  </div>
                  {/* Technicals from Barchart */}
                  {c.market_source === 'barchart' && (
                    <div className="text-right border-l pl-4 ml-2">
                      <p className="text-gray-500 text-xs">RSI / Stoch</p>
                      <div className="flex items-center justify-end gap-1">
                        <span className={`font-medium ${c.market_rsi > 70 ? 'text-red-600' : c.market_rsi < 30 ? 'text-green-600' : 'text-gray-700'}`}>
                          {c.market_rsi?.toFixed(0) || '-'}
                        </span>
                        <span className="text-gray-300">/</span>
                        <span className={`font-medium ${c.market_stoch_d > 80 ? 'text-red-600' : c.market_stoch_d < 20 ? 'text-green-600' : 'text-gray-700'}`}>
                          {c.market_stoch_d?.toFixed(0) || '-'}
                        </span>
                      </div>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Progress bar */}
              <div className="relative">
                <div className={`h-6 rounded-full ${colors.bg} overflow-hidden`}>
                  <div className={`h-full ${colors.fill} rounded-full transition-all duration-300`} style={{ width: `${Math.min(displayPercent, 100)}%` }} />
                </div>
                <span className="absolute right-2 top-1/2 -translate-y-1/2 text-sm font-bold text-gray-700">{formatPercent(displayPercent)}</span>
              </div>

              {/* Contract summary */}
              <div className="mt-3 flex flex-wrap gap-x-4 gap-y-1 text-xs text-gray-500">
                {Object.entries(c.contracts_by_type).map(([type, data]) => {
                  if (data.count === 0) return null;
                  if (type === 'OPTIONS') {
                    const parts = [];
                    if (data.long_put > 0) parts.push(`${data.long_put} Long PUT`);
                    if (data.short_call > 0) parts.push(`${data.short_call} Short CALL`);
                    if (data.long_call > 0) parts.push(`${data.long_call} Long CALL`);
                    if (data.short_put > 0) parts.push(`${data.short_put} Short PUT`);
                    return parts.length > 0 && <span key={type}>OPTIONS: {parts.join(', ')}</span>;
                  }
                  return <span key={type}>{type}: {data.count} ({formatNumber(data.bushels)} bu)</span>;
                })}
              </div>
            </div>
          );
        })}

        {(!data?.commodities || data.commodities.length === 0) && (
          <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-8 text-center text-gray-500">
            No production data for {cropYear}. Add crops in the Production page.
          </div>
        )}
      </div>
    </div>
  );
}

// Add Sale Page
function AddSalePage({ cropYear: initialCropYear, onSuccess, onYearChange }) {
  const [commodities, setCommodities] = useState([]);
  const [buyers, setBuyers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [message, setMessage] = useState(null);

  // Crop year state - can be changed on this page
  const currentYear = new Date().getFullYear();
  const cropYears = [currentYear - 1, currentYear, currentYear + 1, currentYear + 2];
  const [selectedCropYear, setSelectedCropYear] = useState(initialCropYear);

  const [contractType, setContractType] = useState('CASH');
  const [commodityId, setCommodityId] = useState('');
  const [bushels, setBushels] = useState('');
  const [numContracts, setNumContracts] = useState(''); // For OPTIONS - number of contracts
  const [buyerId, setBuyerId] = useState('');
  const [cashPrice, setCashPrice] = useState('');
  const [futuresPrice, setFuturesPrice] = useState('');
  const [expectedBasis, setExpectedBasis] = useState('');
  const [basis, setBasis] = useState('');
  const [optionType, setOptionType] = useState('PUT');
  const [strikePrice, setStrikePrice] = useState('');
  const [premium, setPremium] = useState('');
  const [futuresMonth, setFuturesMonth] = useState('');
  const [deliveryStart, setDeliveryStart] = useState('');
  const [deliveryEnd, setDeliveryEnd] = useState('');
  const [contractNumber, setContractNumber] = useState('');
  const [notes, setNotes] = useState('');
  // New state for LONG/SHORT positions and strategy linking
  const [positionType, setPositionType] = useState('LONG');
  const [linkedContractIds, setLinkedContractIds] = useState([]);
  const [strategyType, setStrategyType] = useState('');
  const [existingOptions, setExistingOptions] = useState([]);
  const [existingStrategyGroups, setExistingStrategyGroups] = useState([]);

  // Contract size for options (bushels per contract)
  const BUSHELS_PER_CONTRACT = 5000;

  useEffect(() => {
    async function load() {
      const [comms, buys, contracts] = await Promise.all([
        getCommodities(),
        getBuyers(),
        getContracts(selectedCropYear)
      ]);
      setCommodities(comms);
      setBuyers(buys);
      // Filter for linkable OPTIONS contracts
      const optionsContracts = contracts.filter(c => c.contract_type === 'OPTIONS');
      setExistingOptions(optionsContracts);
      // Group existing strategy groups
      const groups = new Map();
      optionsContracts.forEach(c => {
        if (c.strategy_group_id) {
          if (!groups.has(c.strategy_group_id)) {
            groups.set(c.strategy_group_id, { id: c.strategy_group_id, contracts: [], type: c.strategy_type });
          }
          groups.get(c.strategy_group_id).contracts.push(c);
        }
      });
      setExistingStrategyGroups(Array.from(groups.values()));
      if (comms.length > 0) setCommodityId(comms[0].id);
      setLoading(false);
    }
    load();
  }, [selectedCropYear]);

  // Sync with parent crop year if it changes
  useEffect(() => {
    setSelectedCropYear(initialCropYear);
  }, [initialCropYear]);

  // Handle crop year change - also update parent
  const handleCropYearChange = (year) => {
    setSelectedCropYear(year);
    if (onYearChange) onYearChange(year);
  };

  const resetForm = () => {
    setContractType('CASH');
    if (commodities.length > 0) setCommodityId(commodities[0].id);
    setBushels('');
    setNumContracts('');
    setBuyerId('');
    setCashPrice('');
    setFuturesPrice('');
    setExpectedBasis('');
    setBasis('');
    setOptionType('PUT');
    setStrikePrice('');
    setPremium('');
    setFuturesMonth('');
    setDeliveryStart('');
    setDeliveryEnd('');
    setContractNumber('');
    setNotes('');
    setPositionType('LONG');
    setLinkedContractIds([]);
    setStrategyType('');
  };

  const getFuturesMonthOptions = () => {
    const months = [];
    const now = new Date();
    for (let i = 0; i < 24; i++) {
      const d = new Date(now.getFullYear(), now.getMonth() + i, 1);
      months.push(d.toLocaleDateString('en-US', { year: 'numeric', month: 'short' }));
    }
    return months;
  };

  // Detect collar strategy when linking options
  // Collar = any combination of Long PUTs + Short CALLs (e.g., 1 put + 2 calls)
  const detectStrategy = (currentOptionType, currentPositionType, linkedOptions) => {
    if (!linkedOptions || linkedOptions.length === 0) return '';

    // Combine current option with linked options for analysis
    const allOptions = [
      { option_type: currentOptionType, position_type: currentPositionType },
      ...linkedOptions.map(o => ({ option_type: o.option_type, position_type: o.position_type || 'LONG' }))
    ];

    const hasLongPut = allOptions.some(o => o.option_type === 'PUT' && o.position_type === 'LONG');
    const hasShortCall = allOptions.some(o => o.option_type === 'CALL' && o.position_type === 'SHORT');

    // Collar: Has at least one Long PUT and at least one Short CALL
    if (hasLongPut && hasShortCall) return 'COLLAR';

    return '';
  };

  const handleLinkedContractsChange = (contractIds) => {
    setLinkedContractIds(contractIds);
    if (contractIds.length > 0) {
      const linkedOptions = existingOptions.filter(o => contractIds.includes(o.id));
      const detected = detectStrategy(optionType, positionType, linkedOptions);
      setStrategyType(detected);
    } else {
      setStrategyType('');
    }
  };

  // Toggle a contract in the linked list
  const toggleLinkedContract = (contractId) => {
    const newIds = linkedContractIds.includes(contractId)
      ? linkedContractIds.filter(id => id !== contractId)
      : [...linkedContractIds, contractId];
    handleLinkedContractsChange(newIds);
  };

  // Update strategy detection when option type or position type changes
  useEffect(() => {
    if (linkedContractIds.length > 0) {
      const linkedOptions = existingOptions.filter(o => linkedContractIds.includes(o.id));
      const detected = detectStrategy(optionType, positionType, linkedOptions);
      setStrategyType(detected);
    }
  }, [optionType, positionType, linkedContractIds, existingOptions]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    // For OPTIONS, require numContracts; for others, require bushels
    if (!commodityId) {
      setMessage({ type: 'error', text: 'Commodity is required' });
      return;
    }
    if (contractType === 'OPTIONS' && !numContracts) {
      setMessage({ type: 'error', text: 'Number of contracts is required' });
      return;
    }
    if (contractType !== 'OPTIONS' && !bushels) {
      setMessage({ type: 'error', text: 'Bushels are required' });
      return;
    }

    setSaving(true);

    // Calculate bushels for OPTIONS from numContracts
    const finalBushels = contractType === 'OPTIONS'
      ? parseInt(numContracts) * BUSHELS_PER_CONTRACT
      : parseInt(bushels);

    // Determine strategy_group_id
    let strategyGroupId = null;
    if (contractType === 'OPTIONS' && linkedContractIds.length > 0) {
      // Check if any linked contract already has a strategy_group_id
      const linkedOptions = existingOptions.filter(o => linkedContractIds.includes(o.id));
      const existingGroupId = linkedOptions.find(o => o.strategy_group_id)?.strategy_group_id;
      // Use existing group ID or generate new one
      strategyGroupId = existingGroupId || crypto.randomUUID();
    }

    const contract = {
      contract_type: contractType,
      crop_year: selectedCropYear,
      commodity_id: commodityId,
      bushels: finalBushels,
      buyer_id: buyerId || null,
      cash_price: cashPrice ? parseFloat(cashPrice) : null,
      futures_price: futuresPrice ? parseFloat(futuresPrice) : null,
      expected_basis: expectedBasis ? parseFloat(expectedBasis) : null,
      basis: basis ? parseFloat(basis) : null,
      option_type: contractType === 'OPTIONS' ? optionType : null,
      strike_price: strikePrice ? parseFloat(strikePrice) : null,
      premium: premium ? parseFloat(premium) : null,
      futures_month: futuresMonth || null,
      delivery_start: deliveryStart || null,
      delivery_end: deliveryEnd || null,
      contract_number: contractNumber || null,
      notes: notes || null,
      position_type: contractType === 'OPTIONS' ? positionType : null,
      strategy_group_id: strategyGroupId,
      strategy_type: contractType === 'OPTIONS' && strategyType ? strategyType : null
    };

    const result = await createContract(contract);
    if (result) {
      // Update linked contracts to join the same strategy group
      if (strategyGroupId && linkedContractIds.length > 0) {
        await supabase
          .from('contracts')
          .update({ strategy_group_id: strategyGroupId, strategy_type: strategyType })
          .in('id', linkedContractIds);
      }

      setMessage({ type: 'success', text: 'Contract created successfully!' });
      resetForm();
      // Reload existing options
      const contracts = await getContracts(selectedCropYear);
      const optionsContracts = contracts.filter(c => c.contract_type === 'OPTIONS');
      setExistingOptions(optionsContracts);
      // Update strategy groups
      const groups = new Map();
      optionsContracts.forEach(c => {
        if (c.strategy_group_id) {
          if (!groups.has(c.strategy_group_id)) {
            groups.set(c.strategy_group_id, { id: c.strategy_group_id, contracts: [], type: c.strategy_type });
          }
          groups.get(c.strategy_group_id).contracts.push(c);
        }
      });
      setExistingStrategyGroups(Array.from(groups.values()));
      setTimeout(() => onSuccess?.(), 1500);
    } else {
      setMessage({ type: 'error', text: 'Failed to create contract' });
    }
    setSaving(false);
    setTimeout(() => setMessage(null), 3000);
  };

  if (loading) return <div className="flex items-center justify-center h-64"><Icon name="refresh-cw" className="animate-spin text-amber-600" size={32} /></div>;

  return (
    <div className="max-w-2xl mx-auto">
      <div className="mb-6 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Add New Sale</h1>
          <p className="text-sm text-gray-500 mt-1">Create a new contract for {selectedCropYear} crop year</p>
        </div>
        <select value={selectedCropYear} onChange={(e) => handleCropYearChange(parseInt(e.target.value))}
          className="px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium focus:ring-2 focus:ring-amber-500">
          {cropYears.map(year => <option key={year} value={year}>{year} Crop Year</option>)}
        </select>
      </div>

      {message && (
        <div className={`mb-4 px-4 py-3 rounded-lg flex items-center gap-2 text-sm ${
          message.type === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
          <Icon name={message.type === 'success' ? 'check' : 'x'} size={16} />
          {message.text}
        </div>
      )}

      <form onSubmit={handleSubmit} className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 space-y-4">
        {/* Contract Type */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">Contract Type</label>
          <div className="grid grid-cols-5 gap-2">
            {['CASH', 'FUTURES', 'OPTIONS', 'HTA', 'BASIS'].map(type => (
              <button key={type} type="button" onClick={() => setContractType(type)}
                className={`py-2 px-3 rounded-lg text-sm font-medium border ${
                  contractType === type ? 'bg-amber-500 text-white border-amber-500' : 'bg-white text-gray-700 border-gray-300'}`}>
                {type}
              </button>
            ))}
          </div>
        </div>

        {/* Commodity */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">Commodity *</label>
          <select value={commodityId} onChange={(e) => setCommodityId(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500">
            {commodities.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
          </select>
        </div>

        {/* Bushels or Number of Contracts */}
        {contractType === 'OPTIONS' ? (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Number of Contracts *</label>
            <input type="number" value={numContracts} onChange={(e) => setNumContracts(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" required min="1" />
            <p className="mt-1 text-xs text-gray-500">
              {numContracts ? `= ${(parseInt(numContracts) * BUSHELS_PER_CONTRACT).toLocaleString()} bushels` : '1 contract = 5,000 bushels'}
            </p>
          </div>
        ) : (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Bushels *</label>
            <input type="number" value={bushels} onChange={(e) => setBushels(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" required />
          </div>
        )}

        {/* Buyer */}
        {['CASH', 'HTA', 'BASIS'].includes(contractType) && (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Buyer</label>
            <select value={buyerId} onChange={(e) => setBuyerId(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500">
              <option value="">Select buyer...</option>
              {buyers.map(b => <option key={b.id} value={b.id}>{b.name}</option>)}
            </select>
          </div>
        )}

        {/* Cash Price */}
        {contractType === 'CASH' && (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Cash Price ($/bu)</label>
            <input type="number" step="0.01" value={cashPrice} onChange={(e) => setCashPrice(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
          </div>
        )}

        {/* Futures/HTA */}
        {['FUTURES', 'HTA'].includes(contractType) && (
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Futures Price ($/bu)</label>
              <input type="number" step="0.01" value={futuresPrice} onChange={(e) => setFuturesPrice(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Expected Basis</label>
              <input type="number" step="0.01" value={expectedBasis} onChange={(e) => setExpectedBasis(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
            </div>
          </div>
        )}

        {/* Basis Contract */}
        {contractType === 'BASIS' && (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Basis ($/bu)</label>
            <input type="number" step="0.01" value={basis} onChange={(e) => setBasis(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
          </div>
        )}

        {/* Options */}
        {contractType === 'OPTIONS' && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Option Type</label>
              <div className="flex gap-2">
                <button type="button" onClick={() => setOptionType('PUT')}
                  className={`px-4 py-2 rounded-lg text-sm font-medium border ${
                    optionType === 'PUT' ? 'bg-orange-500 text-white border-orange-500' : 'bg-white text-gray-700 border-gray-300'}`}>
                  PUT
                </button>
                <button type="button" onClick={() => setOptionType('CALL')}
                  className={`px-4 py-2 rounded-lg text-sm font-medium border ${
                    optionType === 'CALL' ? 'bg-cyan-500 text-white border-cyan-500' : 'bg-white text-gray-700 border-gray-300'}`}>
                  CALL
                </button>
              </div>
            </div>
            {/* Position Type: LONG (Buy) or SHORT (Sell) */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Position Type</label>
              <div className="flex gap-2">
                <button type="button" onClick={() => setPositionType('LONG')}
                  className={`px-4 py-2 rounded-lg text-sm font-medium border ${
                    positionType === 'LONG' ? 'bg-green-500 text-white border-green-500' : 'bg-white text-gray-700 border-gray-300'}`}>
                  LONG (Buy)
                </button>
                <button type="button" onClick={() => setPositionType('SHORT')}
                  className={`px-4 py-2 rounded-lg text-sm font-medium border ${
                    positionType === 'SHORT' ? 'bg-red-500 text-white border-red-500' : 'bg-white text-gray-700 border-gray-300'}`}>
                  SHORT (Sell)
                </button>
              </div>
              <p className="mt-1 text-xs text-gray-500">
                {positionType === 'LONG' ? 'You are buying this option (paying premium)' : 'You are selling this option (receiving premium)'}
              </p>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Strike Price ($/bu)</label>
                <input type="number" step="0.01" value={strikePrice} onChange={(e) => setStrikePrice(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  {positionType === 'LONG' ? 'Premium Paid ($/bu)' : 'Premium Received ($/bu)'}
                </label>
                <div className="relative">
                  <span className={`absolute left-3 top-1/2 -translate-y-1/2 text-sm font-medium ${
                    positionType === 'LONG' ? 'text-red-500' : 'text-green-500'}`}>
                    {positionType === 'LONG' ? '-' : '+'}
                  </span>
                  <input type="number" step="0.01" value={premium} onChange={(e) => setPremium(e.target.value)}
                    className="w-full pl-7 pr-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                </div>
              </div>
            </div>
            {/* Link to existing options for strategies (multi-select) */}
            {existingOptions.filter(o => o.commodity_id === commodityId).length > 0 && (
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Link to Existing Options</label>
                <div className="border border-gray-300 rounded-lg p-2 max-h-40 overflow-y-auto space-y-1">
                  {existingOptions
                    .filter(o => o.commodity_id === commodityId)
                    .map(o => (
                      <label key={o.id} className={`flex items-center gap-2 p-2 rounded cursor-pointer hover:bg-gray-50 ${
                        linkedContractIds.includes(o.id) ? 'bg-amber-50 border border-amber-200' : ''
                      }`}>
                        <input
                          type="checkbox"
                          checked={linkedContractIds.includes(o.id)}
                          onChange={() => toggleLinkedContract(o.id)}
                          className="w-4 h-4 text-amber-500 rounded focus:ring-amber-500"
                        />
                        <span className={`px-1.5 py-0.5 rounded text-xs font-medium ${
                          (o.position_type || 'LONG') === 'SHORT' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'
                        }`}>{o.position_type || 'LONG'}</span>
                        <span className={`px-1.5 py-0.5 rounded text-xs font-medium ${
                          o.option_type === 'PUT' ? 'bg-orange-100 text-orange-700' : 'bg-cyan-100 text-cyan-700'
                        }`}>{o.option_type}</span>
                        <span className="text-sm text-gray-700">@ ${o.strike_price?.toFixed(2)}</span>
                        <span className="text-xs text-gray-500">({o.futures_month || 'No month'})</span>
                        {o.strategy_group_id && (
                          <span className="ml-auto px-1.5 py-0.5 rounded text-xs bg-indigo-100 text-indigo-700">
                            In {o.strategy_type || 'Strategy'}
                          </span>
                        )}
                      </label>
                    ))}
                </div>
                {linkedContractIds.length > 0 && (
                  <div className="mt-2 text-xs text-gray-600">
                    {linkedContractIds.length} option{linkedContractIds.length !== 1 ? 's' : ''} selected
                  </div>
                )}
                {strategyType && (
                  <div className="mt-2 inline-flex items-center gap-1 px-2 py-1 bg-purple-100 text-purple-700 rounded text-xs font-medium">
                    <Icon name="link" size={12} />
                    {strategyType} Strategy Detected
                  </div>
                )}
                <p className="mt-1 text-xs text-gray-500">
                  Collar = Long PUT(s) + Short CALL(s). Select multiple options to create multi-leg strategies.
                </p>
              </div>
            )}
          </div>
        )}

        {/* Futures Month */}
        {['FUTURES', 'OPTIONS', 'HTA', 'BASIS'].includes(contractType) && (
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Futures Month</label>
            <select value={futuresMonth} onChange={(e) => setFuturesMonth(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500">
              <option value="">Select month...</option>
              {getFuturesMonthOptions().map(m => <option key={m} value={m}>{m}</option>)}
            </select>
          </div>
        )}

        {/* Delivery Window */}
        {['CASH', 'HTA', 'BASIS'].includes(contractType) && (
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Delivery Start</label>
              <input type="date" value={deliveryStart} onChange={(e) => setDeliveryStart(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Delivery End</label>
              <input type="date" value={deliveryEnd} onChange={(e) => setDeliveryEnd(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
            </div>
          </div>
        )}

        {/* Contract Number */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">Contract Number</label>
          <input type="text" value={contractNumber} onChange={(e) => setContractNumber(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
        </div>

        {/* Notes */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">Notes</label>
          <textarea value={notes} onChange={(e) => setNotes(e.target.value)} rows={2}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
        </div>

        {/* Submit */}
        <div className="flex justify-end gap-3 pt-4 border-t border-gray-200">
          <button type="button" onClick={resetForm} className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-lg">Clear</button>
          <button type="submit" disabled={saving}
            className="flex items-center gap-2 px-6 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600 disabled:opacity-50">
            {saving ? <Icon name="refresh-cw" className="animate-spin" size={16} /> : <Icon name="save" size={16} />}
            Create Contract
          </button>
        </div>
      </form>
    </div>
  );
}

// Contracts Page
function ContractsPage({ cropYear, onYearChange }) {
  const [contracts, setContracts] = useState([]);
  const [commodities, setCommodities] = useState([]);
  const [buyers, setBuyers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filterCommodity, setFilterCommodity] = useState('');
  const [filterType, setFilterType] = useState('');
  const [editingContract, setEditingContract] = useState(null);
  const [editForm, setEditForm] = useState({});
  const [saving, setSaving] = useState(false);
  const [confirmDelete, setConfirmDelete] = useState(null);
  const { addToast } = useToast();

  const currentYear = new Date().getFullYear();
  const cropYears = [currentYear - 1, currentYear, currentYear + 1, currentYear + 2];

  const loadData = async () => {
    setLoading(true);
    const [cons, comms, buys] = await Promise.all([
      getContracts(cropYear),
      getCommodities(),
      getBuyers()
    ]);
    setContracts(cons);
    setCommodities(comms);
    setBuyers(buys);
    setLoading(false);
  };

  useEffect(() => { loadData(); }, [cropYear]);

  const handleDelete = async (contract) => {
    setConfirmDelete(contract);
  };

  const confirmDeleteContract = async () => {
    const contract = confirmDelete;
    setConfirmDelete(null);

    const oldRecord = await deleteContract(contract.id);
    if (oldRecord) {
      loadData();
      addToast(`Contract cancelled: ${contract.bushels?.toLocaleString()} bu ${contract.commodity_name}`, {
        type: 'warning',
        undoAction: async () => {
          await restoreContract(contract.id);
          loadData();
          addToast('Contract restored', { type: 'success' });
        }
      });
    }
  };

  const handleEdit = (contract) => {
    setEditingContract(contract);
    setEditForm({
      bushels: contract.bushels || '',
      cash_price: contract.cash_price || '',
      futures_price: contract.futures_price || '',
      basis: contract.basis || '',
      expected_basis: contract.expected_basis || '',
      option_type: contract.option_type || 'PUT',
      position_type: contract.position_type || 'LONG',
      strike_price: contract.strike_price || '',
      premium: contract.premium || '',
      futures_month: contract.futures_month || '',
      delivery_start: contract.delivery_start || '',
      delivery_end: contract.delivery_end || '',
      contract_number: contract.contract_number || '',
      notes: contract.notes || '',
      buyer_id: contract.buyer_id || ''
    });
  };

  const handleEditSave = async () => {
    if (!editingContract) return;
    setSaving(true);
    const updates = {
      bushels: editForm.bushels ? parseInt(editForm.bushels) : null,
      contract_number: editForm.contract_number || null,
      notes: editForm.notes || null,
      futures_month: editForm.futures_month || null
    };

    if (editingContract.contract_type === 'CASH') {
      updates.cash_price = editForm.cash_price ? parseFloat(editForm.cash_price) : null;
      updates.buyer_id = editForm.buyer_id || null;
      updates.delivery_start = editForm.delivery_start || null;
      updates.delivery_end = editForm.delivery_end || null;
    } else if (editingContract.contract_type === 'FUTURES' || editingContract.contract_type === 'HTA') {
      updates.futures_price = editForm.futures_price ? parseFloat(editForm.futures_price) : null;
      updates.expected_basis = editForm.expected_basis ? parseFloat(editForm.expected_basis) : null;
      if (editingContract.contract_type === 'HTA') {
        updates.buyer_id = editForm.buyer_id || null;
        updates.delivery_start = editForm.delivery_start || null;
        updates.delivery_end = editForm.delivery_end || null;
      }
    } else if (editingContract.contract_type === 'BASIS') {
      updates.basis = editForm.basis ? parseFloat(editForm.basis) : null;
      updates.buyer_id = editForm.buyer_id || null;
      updates.delivery_start = editForm.delivery_start || null;
      updates.delivery_end = editForm.delivery_end || null;
    } else if (editingContract.contract_type === 'OPTIONS') {
      updates.option_type = editForm.option_type;
      updates.position_type = editForm.position_type;
      updates.strike_price = editForm.strike_price ? parseFloat(editForm.strike_price) : null;
      updates.premium = editForm.premium ? parseFloat(editForm.premium) : null;
    }

    const result = await updateContract(editingContract.id, updates);
    if (result) {
      setEditingContract(null);
      loadData();
    }
    setSaving(false);
  };

  const getFuturesMonthOptions = () => {
    const months = [];
    const now = new Date();
    for (let i = -12; i < 24; i++) {
      const d = new Date(now.getFullYear(), now.getMonth() + i, 1);
      months.push(d.toLocaleDateString('en-US', { year: 'numeric', month: 'short' }));
    }
    return months;
  };

  const filteredContracts = contracts.filter(c => {
    if (filterCommodity && c.commodity_id !== filterCommodity) return false;
    if (filterType && c.contract_type !== filterType) return false;
    return true;
  });

  const formatNumber = (n) => n?.toLocaleString() || '-';
  const formatPrice = (n) => n ? '$' + n.toFixed(2) : '-';
  const formatDelivery = (c) => {
    if (c.delivery_start && c.delivery_end) return `${c.delivery_start} - ${c.delivery_end}`;
    if (c.delivery_start) return c.delivery_start;
    if (c.futures_month) return c.futures_month;
    return '-';
  };
  const formatPremium = (c) => {
    if (c.contract_type !== 'OPTIONS' || !c.premium) return null;
    const isShort = c.position_type === 'SHORT';
    return {
      value: c.premium,
      sign: isShort ? '+' : '-',
      colorClass: isShort ? 'text-green-600' : 'text-red-600'
    };
  };

  if (loading) return <div className="flex items-center justify-center h-64"><Icon name="refresh-cw" className="animate-spin text-amber-600" size={32} /></div>;

  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Contracts</h1>
          <p className="text-sm text-gray-500 mt-1">View and manage grain contracts</p>
        </div>
        <div className="flex items-center gap-3">
          <select value={filterCommodity} onChange={(e) => setFilterCommodity(e.target.value)}
            className="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-amber-500">
            <option value="">All Commodities</option>
            {commodities.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
          </select>
          <select value={filterType} onChange={(e) => setFilterType(e.target.value)}
            className="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-amber-500">
            <option value="">All Types</option>
            {['CASH', 'FUTURES', 'OPTIONS', 'HTA', 'BASIS'].map(t => <option key={t} value={t}>{t}</option>)}
          </select>
          <select value={cropYear} onChange={(e) => onYearChange(parseInt(e.target.value))}
            className="px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium focus:ring-2 focus:ring-amber-500">
            {cropYears.map(year => <option key={year} value={year}>{year}</option>)}
          </select>
        </div>
      </div>

      {/* Options Premium Summary */}
      {(() => {
        const optionsContracts = filteredContracts.filter(c => c.contract_type === 'OPTIONS');
        if (optionsContracts.length === 0) return null;

        let premiumPaid = 0;
        let premiumReceived = 0;
        let unrealizedPnL = 0;
        let quotedCount = 0;
        let longPuts = 0, shortCalls = 0, longCalls = 0, shortPuts = 0;

        optionsContracts.forEach(c => {
          const isShort = c.position_type === 'SHORT';
          const isPut = c.option_type === 'PUT';
          const premiumTotal = (c.premium || 0) * (c.bushels || 0);

          if (isShort) {
            premiumReceived += premiumTotal;
            if (isPut) shortPuts++; else shortCalls++;
          } else {
            premiumPaid += premiumTotal;
            if (isPut) longPuts++; else longCalls++;
          }

          // Add up unrealized P&L from matched quotes
          if (c.option_pnl) {
            unrealizedPnL += c.option_pnl.total;
            quotedCount++;
          }
        });

        const netPremium = premiumReceived - premiumPaid;

        return (
          <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-4">
            <div className="flex flex-wrap items-center justify-between gap-4">
              <div className="flex items-center gap-6">
                <span className="text-sm font-medium text-gray-700">Options Summary:</span>
                {longPuts > 0 && <span className="text-xs px-2 py-1 bg-green-100 text-green-700 rounded">{longPuts} Long PUT</span>}
                {shortCalls > 0 && <span className="text-xs px-2 py-1 bg-red-100 text-red-700 rounded">{shortCalls} Short CALL</span>}
                {longCalls > 0 && <span className="text-xs px-2 py-1 bg-green-100 text-green-700 rounded">{longCalls} Long CALL</span>}
                {shortPuts > 0 && <span className="text-xs px-2 py-1 bg-red-100 text-red-700 rounded">{shortPuts} Short PUT</span>}
              </div>
              <div className="flex items-center gap-6 text-sm">
                <div>
                  <span className="text-gray-500">Paid: </span>
                  <span className="font-medium text-red-600">-${premiumPaid.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                </div>
                <div>
                  <span className="text-gray-500">Received: </span>
                  <span className="font-medium text-green-600">+${premiumReceived.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                </div>
                <div className={`font-bold ${netPremium >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                  Net: {netPremium >= 0 ? '+' : ''}${netPremium.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                </div>
                {quotedCount > 0 && (
                  <div className={`font-bold border-l pl-4 ${unrealizedPnL >= 0 ? 'text-green-600' : 'text-red-600'}`}
                    title={`Based on ${quotedCount} option(s) with live quotes`}>
                    Unrealized: {unrealizedPnL >= 0 ? '+' : ''}${unrealizedPnL.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      })()}

      <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
        <div className="overflow-x-auto">
          <table className="w-full text-sm">
            <thead className="bg-gray-50 border-b border-gray-200">
              <tr>
                <th className="text-left px-4 py-3 font-semibold text-gray-700">Date</th>
                <th className="text-left px-4 py-3 font-semibold text-gray-700">Type</th>
                <th className="text-left px-4 py-3 font-semibold text-gray-700">Commodity</th>
                <th className="text-right px-4 py-3 font-semibold text-gray-700">Bushels</th>
                <th className="text-right px-4 py-3 font-semibold text-gray-700">Price</th>
                <th className="text-left px-4 py-3 font-semibold text-gray-700">Buyer</th>
                <th className="text-left px-4 py-3 font-semibold text-gray-700">Delivery</th>
                <th className="text-center px-4 py-3 font-semibold text-gray-700">Actions</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-100">
              {filteredContracts.map(c => {
                const premiumInfo = formatPremium(c);
                return (
                  <tr key={c.id} className="hover:bg-gray-50">
                    <td className="px-4 py-3 text-gray-600">{c.contract_date}</td>
                    <td className="px-4 py-3">
                      <div className="flex flex-wrap gap-1">
                        <span className={`px-2 py-1 rounded text-xs font-medium ${
                          c.contract_type === 'CASH' ? 'bg-green-100 text-green-700' :
                          c.contract_type === 'FUTURES' ? 'bg-blue-100 text-blue-700' :
                          c.contract_type === 'OPTIONS' ? 'bg-purple-100 text-purple-700' :
                          c.contract_type === 'HTA' ? 'bg-amber-100 text-amber-700' :
                          'bg-gray-100 text-gray-700'
                        }`}>{c.contract_type}</span>
                        {c.contract_type === 'OPTIONS' && (
                          <>
                            <span className={`px-2 py-1 rounded text-xs font-medium ${
                              c.option_type === 'PUT' ? 'bg-orange-100 text-orange-700' : 'bg-cyan-100 text-cyan-700'
                            }`}>{c.option_type}</span>
                            <span className={`px-2 py-1 rounded text-xs font-medium ${
                              c.position_type === 'SHORT' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'
                            }`}>{c.position_type || 'LONG'}</span>
                            {c.futures_month && (
                              <span className="px-2 py-1 rounded text-xs font-medium bg-gray-100 text-gray-700">
                                {c.futures_month}
                              </span>
                            )}
                            {c.strategy_type && (
                              <span className="px-2 py-1 rounded text-xs font-medium bg-indigo-100 text-indigo-700 flex items-center gap-1" title={c.strategy_members?.length > 0 ? `Linked with ${c.strategy_members.length} other option(s)` : ''}>
                                <Icon name="link" size={10} />
                                {c.strategy_type}
                                {c.strategy_members?.length > 0 && (
                                  <span className="ml-0.5 px-1 py-0.5 bg-indigo-200 rounded-full text-[10px]">
                                    +{c.strategy_members.length}
                                  </span>
                                )}
                              </span>
                            )}
                          </>
                        )}
                      </div>
                    </td>
                    <td className="px-4 py-3 font-medium text-gray-900">{c.commodity_name}</td>
                    <td className="px-4 py-3 text-right text-gray-900">
                      {c.contract_type === 'OPTIONS' ? (
                        <div>
                          <div>{Math.floor(c.bushels / 5000)} contract{Math.floor(c.bushels / 5000) !== 1 ? 's' : ''}</div>
                          <div className="text-xs text-gray-500">{formatNumber(c.bushels)} bu</div>
                        </div>
                      ) : (
                        formatNumber(c.bushels)
                      )}
                    </td>
                    <td className="px-4 py-3 text-right font-medium text-gray-900">
                      <div>{formatPrice(c.effective_price)}</div>
                      {premiumInfo && (
                        <div className={`text-xs ${premiumInfo.colorClass}`}>
                          {premiumInfo.sign}${premiumInfo.value.toFixed(2)} prem
                        </div>
                      )}
                      {c.option_pnl && (
                        <div className="mt-1 pt-1 border-t border-gray-100">
                          <div className="text-xs text-gray-500">
                            Now: ${c.option_pnl.current_premium.toFixed(4)}
                          </div>
                          <div className={`text-xs font-semibold ${c.option_pnl.total >= 0 ? 'text-green-600' : 'text-red-600'}`}
                            title={`${c.option_pnl.per_bushel >= 0 ? '+' : ''}$${c.option_pnl.per_bushel.toFixed(4)}/bu`}>
                            P&L: {c.option_pnl.total >= 0 ? '+' : ''}${c.option_pnl.total.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                          </div>
                        </div>
                      )}
                      {c.contract_type === 'OPTIONS' && !c.option_pnl && c.option_quote === null && (
                        <div className="text-xs text-gray-400 italic">No quote</div>
                      )}
                    </td>
                    <td className="px-4 py-3 text-gray-600">{c.buyer_name || '-'}</td>
                    <td className="px-4 py-3 text-gray-600">{formatDelivery(c)}</td>
                    <td className="px-4 py-3 text-center">
                      <div className="flex items-center justify-center gap-1">
                        <button onClick={() => handleEdit(c)} className="p-1.5 text-blue-500 hover:bg-blue-50 rounded" title="Edit">
                          <Icon name="edit-2" size={16} />
                        </button>
                        <button onClick={() => handleDelete(c)} className="p-1.5 text-red-500 hover:bg-red-50 rounded" title="Cancel">
                          <Icon name="trash-2" size={16} />
                        </button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
        {filteredContracts.length === 0 && (
          <div className="p-8 text-center text-gray-500">
            <Icon name="file-text" size={48} className="mx-auto mb-4 text-gray-300" />
            <p>No contracts found for {cropYear}</p>
          </div>
        )}
      </div>

      {/* Edit Contract Modal */}
      {editingContract && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-xl max-w-lg w-full max-h-[90vh] overflow-y-auto">
            <div className="p-6 border-b border-gray-200">
              <div className="flex items-center justify-between">
                <h2 className="text-xl font-bold text-gray-900">Edit {editingContract.contract_type} Contract</h2>
                <button onClick={() => setEditingContract(null)} className="p-2 hover:bg-gray-100 rounded-lg">
                  <Icon name="x" size={20} />
                </button>
              </div>
            </div>
            <div className="p-6 space-y-4">
              {/* Bushels or Number of Contracts */}
              {editingContract.contract_type === 'OPTIONS' ? (
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Number of Contracts</label>
                  <input type="number" value={Math.floor((editForm.bushels || 0) / 5000) || ''}
                    onChange={(e) => setEditForm({...editForm, bushels: (parseInt(e.target.value) || 0) * 5000})}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" min="1" />
                  <p className="mt-1 text-xs text-gray-500">
                    {editForm.bushels ? `= ${parseInt(editForm.bushels).toLocaleString()} bushels` : '1 contract = 5,000 bushels'}
                  </p>
                </div>
              ) : (
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Bushels</label>
                  <input type="number" value={editForm.bushels} onChange={(e) => setEditForm({...editForm, bushels: e.target.value})}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                </div>
              )}

              {/* CASH fields */}
              {editingContract.contract_type === 'CASH' && (
                <>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Cash Price ($/bu)</label>
                    <input type="number" step="0.01" value={editForm.cash_price} onChange={(e) => setEditForm({...editForm, cash_price: e.target.value})}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Buyer</label>
                    <select value={editForm.buyer_id} onChange={(e) => setEditForm({...editForm, buyer_id: e.target.value})}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500">
                      <option value="">Select buyer...</option>
                      {buyers.map(b => <option key={b.id} value={b.id}>{b.name}</option>)}
                    </select>
                  </div>
                </>
              )}

              {/* FUTURES/HTA fields */}
              {['FUTURES', 'HTA'].includes(editingContract.contract_type) && (
                <>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Futures Price ($/bu)</label>
                      <input type="number" step="0.01" value={editForm.futures_price} onChange={(e) => setEditForm({...editForm, futures_price: e.target.value})}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Expected Basis</label>
                      <input type="number" step="0.01" value={editForm.expected_basis} onChange={(e) => setEditForm({...editForm, expected_basis: e.target.value})}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                    </div>
                  </div>
                  {editingContract.contract_type === 'HTA' && (
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Buyer</label>
                      <select value={editForm.buyer_id} onChange={(e) => setEditForm({...editForm, buyer_id: e.target.value})}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500">
                        <option value="">Select buyer...</option>
                        {buyers.map(b => <option key={b.id} value={b.id}>{b.name}</option>)}
                      </select>
                    </div>
                  )}
                </>
              )}

              {/* BASIS fields */}
              {editingContract.contract_type === 'BASIS' && (
                <>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Basis ($/bu)</label>
                    <input type="number" step="0.01" value={editForm.basis} onChange={(e) => setEditForm({...editForm, basis: e.target.value})}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Buyer</label>
                    <select value={editForm.buyer_id} onChange={(e) => setEditForm({...editForm, buyer_id: e.target.value})}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500">
                      <option value="">Select buyer...</option>
                      {buyers.map(b => <option key={b.id} value={b.id}>{b.name}</option>)}
                    </select>
                  </div>
                </>
              )}

              {/* OPTIONS fields */}
              {editingContract.contract_type === 'OPTIONS' && (
                <>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Option Type</label>
                    <div className="flex gap-2">
                      <button type="button" onClick={() => setEditForm({...editForm, option_type: 'PUT'})}
                        className={`px-4 py-2 rounded-lg text-sm font-medium border ${
                          editForm.option_type === 'PUT' ? 'bg-orange-500 text-white border-orange-500' : 'bg-white text-gray-700 border-gray-300'}`}>
                        PUT
                      </button>
                      <button type="button" onClick={() => setEditForm({...editForm, option_type: 'CALL'})}
                        className={`px-4 py-2 rounded-lg text-sm font-medium border ${
                          editForm.option_type === 'CALL' ? 'bg-cyan-500 text-white border-cyan-500' : 'bg-white text-gray-700 border-gray-300'}`}>
                        CALL
                      </button>
                    </div>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Position Type</label>
                    <div className="flex gap-2">
                      <button type="button" onClick={() => setEditForm({...editForm, position_type: 'LONG'})}
                        className={`px-4 py-2 rounded-lg text-sm font-medium border ${
                          editForm.position_type === 'LONG' ? 'bg-green-500 text-white border-green-500' : 'bg-white text-gray-700 border-gray-300'}`}>
                        LONG (Buy)
                      </button>
                      <button type="button" onClick={() => setEditForm({...editForm, position_type: 'SHORT'})}
                        className={`px-4 py-2 rounded-lg text-sm font-medium border ${
                          editForm.position_type === 'SHORT' ? 'bg-red-500 text-white border-red-500' : 'bg-white text-gray-700 border-gray-300'}`}>
                        SHORT (Sell)
                      </button>
                    </div>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Strike Price ($/bu)</label>
                      <input type="number" step="0.01" value={editForm.strike_price} onChange={(e) => setEditForm({...editForm, strike_price: e.target.value})}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        {editForm.position_type === 'LONG' ? 'Premium Paid ($/bu)' : 'Premium Received ($/bu)'}
                      </label>
                      <input type="number" step="0.01" value={editForm.premium} onChange={(e) => setEditForm({...editForm, premium: e.target.value})}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                    </div>
                  </div>
                </>
              )}

              {/* Futures Month - for FUTURES, OPTIONS, HTA, BASIS */}
              {['FUTURES', 'OPTIONS', 'HTA', 'BASIS'].includes(editingContract.contract_type) && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Futures Month</label>
                  <select value={editForm.futures_month} onChange={(e) => setEditForm({...editForm, futures_month: e.target.value})}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500">
                    <option value="">Select month...</option>
                    {getFuturesMonthOptions().map(m => <option key={m} value={m}>{m}</option>)}
                  </select>
                </div>
              )}

              {/* Delivery Window - for CASH, HTA, BASIS */}
              {['CASH', 'HTA', 'BASIS'].includes(editingContract.contract_type) && (
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Delivery Start</label>
                    <input type="date" value={editForm.delivery_start} onChange={(e) => setEditForm({...editForm, delivery_start: e.target.value})}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Delivery End</label>
                    <input type="date" value={editForm.delivery_end} onChange={(e) => setEditForm({...editForm, delivery_end: e.target.value})}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
                  </div>
                </div>
              )}

              {/* Contract Number */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Contract Number</label>
                <input type="text" value={editForm.contract_number} onChange={(e) => setEditForm({...editForm, contract_number: e.target.value})}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
              </div>

              {/* Notes */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Notes</label>
                <textarea value={editForm.notes} onChange={(e) => setEditForm({...editForm, notes: e.target.value})} rows={2}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
              </div>
            </div>
            <div className="p-6 border-t border-gray-200 flex justify-end gap-3">
              <button onClick={() => setEditingContract(null)} className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-lg">
                Cancel
              </button>
              <button onClick={handleEditSave} disabled={saving}
                className="flex items-center gap-2 px-6 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600 disabled:opacity-50">
                {saving ? <Icon name="refresh-cw" className="animate-spin" size={16} /> : <Icon name="save" size={16} />}
                Save Changes
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Delete Confirmation Modal */}
      <ConfirmModal
        isOpen={!!confirmDelete}
        title="Cancel Contract"
        message={confirmDelete ? `Are you sure you want to cancel this ${confirmDelete.bushels?.toLocaleString()} bu ${confirmDelete.commodity_name} contract?` : ''}
        confirmText="Cancel Contract"
        cancelText="Keep"
        variant="danger"
        onConfirm={confirmDeleteContract}
        onCancel={() => setConfirmDelete(null)}
      />
    </div>
  );
}

// Production Page
function ProductionPage({ cropYear, onYearChange }) {
  const [commodities, setCommodities] = useState([]);
  const [fields, setFields] = useState([]);
  const [rows, setRows] = useState([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [message, setMessage] = useState(null);
  const [addingToField, setAddingToField] = useState(null);
  const [newCrop, setNewCrop] = useState({ commodity_id: '', planted_acres: '', estimated_yield: '', share_override: '', is_irrigated: false, is_double_crop: false });
  const [collapsedFarms, setCollapsedFarms] = useState(new Set());
  const [confirmDelete, setConfirmDelete] = useState(null);
  const { addToast } = useToast();

  const currentYear = new Date().getFullYear();
  const cropYears = [currentYear - 1, currentYear, currentYear + 1, currentYear + 2];

  const loadData = useCallback(async () => {
    setLoading(true);
    const [comms, flds] = await Promise.all([getCommodities(), getFieldsForGrain()]);
    setCommodities(comms);
    setFields(flds);
    setLoading(false);
  }, []);

  const loadProduction = useCallback(async () => {
    const production = await getProductionByCropYear(cropYear);
    setRows(production.map(r => ({ ...r, isModified: false })));
  }, [cropYear]);

  useEffect(() => { loadData(); }, []);
  useEffect(() => { loadProduction(); }, [cropYear, fields.length]);

  const handleStartAddCrop = (fieldId) => {
    const field = fields.find(f => f.id === fieldId);
    setAddingToField(fieldId);
    setNewCrop({
      commodity_id: commodities[0]?.id || '',
      planted_acres: field?.acres?.toString() || '',
      estimated_yield: '',
      share_override: '',
      is_irrigated: false,
      is_double_crop: false
    });
  };

  const handleCancelAddCrop = () => {
    setAddingToField(null);
    setNewCrop({ commodity_id: '', planted_acres: '', estimated_yield: '', share_override: '', is_irrigated: false, is_double_crop: false });
  };

  const handleAddCrop = async (fieldId) => {
    if (!newCrop.commodity_id || !newCrop.planted_acres || !newCrop.estimated_yield) {
      setMessage({ type: 'error', text: 'Please fill in Crop, Acres, and Yield' });
      setTimeout(() => setMessage(null), 3000);
      return;
    }

    setSaving(true);
    const result = await createCropEntry({
      field_id: fieldId,
      crop_year: cropYear,
      commodity_id: newCrop.commodity_id,
      planted_acres: parseFloat(newCrop.planted_acres),
      estimated_yield: parseFloat(newCrop.estimated_yield),
      share_override: newCrop.share_override ? parseFloat(newCrop.share_override) : null,
      is_irrigated: newCrop.is_irrigated,
      is_double_crop: newCrop.is_double_crop
    });

    if (result) {
      setMessage({ type: 'success', text: 'Crop added successfully' });
      handleCancelAddCrop();
      await loadProduction();
    } else {
      setMessage({ type: 'error', text: 'Failed to add crop' });
    }
    setSaving(false);
    setTimeout(() => setMessage(null), 3000);
  };

  const handleCellChange = (rowId, field, value) => {
    setRows(prev => prev.map(row => {
      if (row.id !== rowId) return row;
      const updated = { ...row, [field]: value, isModified: true };
      const effectiveShare = updated.share_override ?? updated.effective_share;
      updated.expected_marketable = (updated.planted_acres || 0) * (updated.estimated_yield || 0) * effectiveShare;
      updated.actual_marketable = updated.actual_production !== null ? updated.actual_production * effectiveShare : null;
      
      // Update display name
      let displayName = updated.commodity_name;
      if (updated.is_irrigated) displayName += ' IR';
      if (updated.is_double_crop) displayName += ' (DC)';
      updated.display_name = displayName;
      
      return updated;
    }));
  };

  const handleSave = async () => {
    setSaving(true);
    setMessage(null);

    const modifiedRows = rows.filter(r => r.isModified);
    let successCount = 0;
    let errorCount = 0;

    for (const row of modifiedRows) {
      const result = await updateProduction(row.id, {
        planted_acres: row.planted_acres,
        estimated_yield: row.estimated_yield,
        actual_production: row.actual_production,
        share_override: row.share_override,
        is_irrigated: row.is_irrigated,
        is_double_crop: row.is_double_crop,
        status: row.status,
        notes: row.notes
      });
      if (result) successCount++; else errorCount++;
    }

    if (errorCount > 0) setMessage({ type: 'error', text: `Saved ${successCount} rows, ${errorCount} failed` });
    else if (successCount > 0) setMessage({ type: 'success', text: `Saved ${successCount} rows successfully` });

    await loadProduction();
    setSaving(false);
    setTimeout(() => setMessage(null), 3000);
  };

  const handleDelete = (row) => {
    setConfirmDelete(row);
  };

  const confirmDeleteProduction = async () => {
    const row = confirmDelete;
    setConfirmDelete(null);

    const oldRecord = await deleteProduction(row.id);
    if (oldRecord) {
      await loadProduction();
      addToast(`Deleted ${row.display_name} on ${row.field_name}`, {
        type: 'warning',
        undoAction: async () => {
          await restoreProduction(row.id);
          await loadProduction();
          addToast('Crop restored', { type: 'success' });
        }
      });
    } else {
      addToast('Failed to delete', { type: 'error' });
    }
  };

  const toggleFarm = (farmName) => {
    setCollapsedFarms(prev => {
      const next = new Set(prev);
      if (next.has(farmName)) next.delete(farmName); else next.add(farmName);
      return next;
    });
  };

  const hasModifiedRows = rows.some(r => r.isModified);
  const fieldsByFarm = fields.reduce((acc, field) => {
    if (!acc[field.farm_name]) acc[field.farm_name] = [];
    acc[field.farm_name].push(field);
    return acc;
  }, {});
  const getCropsForField = (fieldId) => rows.filter(r => r.field_id === fieldId);

  // Check if selected commodity is Corn (hide double crop checkbox)
  const selectedCommodity = commodities.find(c => c.id === newCrop.commodity_id);
  const isCorn = selectedCommodity?.name === 'Corn';

  if (loading && fields.length === 0) {
    return <div className="flex items-center justify-center h-64"><Icon name="refresh-cw" className="animate-spin text-amber-600" size={32} /></div>;
  }

  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Production Planning</h1>
          <p className="text-sm text-gray-500 mt-1">Enter crop plans and harvest results by field</p>
        </div>
        <div className="flex items-center gap-3">
          <select value={cropYear} onChange={(e) => onYearChange(parseInt(e.target.value))}
            className="px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium focus:ring-2 focus:ring-amber-500">
            {cropYears.map(year => <option key={year} value={year}>{year} Crop Year</option>)}
          </select>
          <button onClick={handleSave} disabled={!hasModifiedRows || saving}
            className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium ${
              hasModifiedRows ? 'bg-amber-500 text-white hover:bg-amber-600' : 'bg-gray-100 text-gray-400 cursor-not-allowed'}`}>
            {saving ? <Icon name="refresh-cw" className="animate-spin" size={16} /> : <Icon name="save" size={16} />}
            Save Changes
          </button>
        </div>
      </div>

      {message && (
        <div className={`px-4 py-3 rounded-lg flex items-center gap-2 text-sm ${
          message.type === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
          <Icon name={message.type === 'success' ? 'check' : 'x'} size={16} />
          {message.text}
        </div>
      )}

      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 text-sm text-blue-800">
        <p><strong>Instructions:</strong> All grain-active fields are shown below. Click "Add Crop" on any field to add a crop. You can add multiple crops per field.</p>
        <p className="mt-1">Check <strong>Irrigated</strong> for irrigated crops. Check <strong>Double Crop</strong> for double-cropped fields (not available for Corn).</p>
        <p className="mt-1">Yellow rows have unsaved changes. Click "Save Changes" when done editing.</p>
      </div>

      {Object.entries(fieldsByFarm).length === 0 ? (
        <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-8 text-center">
          <p className="text-gray-500">No grain-active fields found. Check field settings in the Settings page.</p>
        </div>
      ) : (
        <div className="space-y-4">
          {Object.entries(fieldsByFarm).map(([farmName, farmFields]) => (
            <div key={farmName} className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
              <div className="bg-gray-50 px-4 py-3 border-b border-gray-200 cursor-pointer hover:bg-gray-100 flex items-center justify-between"
                onClick={() => toggleFarm(farmName)}>
                <div className="flex items-center gap-2 font-semibold text-gray-800">
                  <Icon name={collapsedFarms.has(farmName) ? 'chevron-right' : 'chevron-down'} size={18} />
                  {farmName}
                  <span className="text-gray-500 font-normal text-sm">({farmFields.length} field{farmFields.length !== 1 ? 's' : ''})</span>
                </div>
              </div>

              {!collapsedFarms.has(farmName) && (
                <div className="divide-y divide-gray-100">
                  {farmFields.map(field => {
                    const fieldCrops = getCropsForField(field.id);
                    const isAdding = addingToField === field.id;

                    return (
                      <div key={field.id} className="p-4">
                        <div className="flex items-center justify-between mb-2">
                          <div className="flex items-center gap-3">
                            <span className="font-medium text-gray-900">{field.name}</span>
                            <span className="text-sm text-gray-500">{field.acres} total acres</span>
                            <span className="text-xs text-gray-400">({(field.effective_share * 100).toFixed(1)}% share)</span>
                          </div>
                          {!isAdding && (
                            <button onClick={() => handleStartAddCrop(field.id)}
                              className="flex items-center gap-1 px-2 py-1 text-xs bg-green-100 text-green-700 rounded hover:bg-green-200 font-medium">
                              <Icon name="plus" size={14} /> Add Crop
                            </button>
                          )}
                        </div>

                        {/* Add Crop Form */}
                        {isAdding && (
                          <div className="bg-green-50 border border-green-200 rounded-lg p-3 mb-3">
                            <div className="grid grid-cols-2 md:grid-cols-5 gap-2 text-sm items-end">
                              <div>
                                <label className="block text-xs font-medium text-gray-600 mb-1">Crop *</label>
                                <select value={newCrop.commodity_id} 
                                  onChange={(e) => setNewCrop({ ...newCrop, commodity_id: e.target.value, is_double_crop: commodities.find(c => c.id === e.target.value)?.name === 'Corn' ? false : newCrop.is_double_crop })}
                                  className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-green-500">
                                  <option value="">Select...</option>
                                  {commodities.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                </select>
                              </div>
                              <div>
                                <label className="block text-xs font-medium text-gray-600 mb-1">Acres *</label>
                                <input type="number" step="0.1" value={newCrop.planted_acres}
                                  onChange={(e) => setNewCrop({ ...newCrop, planted_acres: e.target.value })}
                                  className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-green-500" />
                              </div>
                              <div>
                                <label className="block text-xs font-medium text-gray-600 mb-1">Yield *</label>
                                <input type="number" step="0.1" value={newCrop.estimated_yield}
                                  onChange={(e) => setNewCrop({ ...newCrop, estimated_yield: e.target.value })}
                                  className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-green-500" />
                              </div>
                              <div className="flex items-center gap-4 pt-4">
                                <label className="flex items-center gap-1.5 text-sm cursor-pointer">
                                  <input type="checkbox" checked={newCrop.is_irrigated}
                                    onChange={(e) => setNewCrop({ ...newCrop, is_irrigated: e.target.checked })}
                                    className="w-4 h-4 rounded border-gray-300 text-amber-500 focus:ring-amber-500" />
                                  <span className="text-gray-700">Irrigated</span>
                                </label>
                                {!isCorn && (
                                  <label className="flex items-center gap-1.5 text-sm cursor-pointer">
                                    <input type="checkbox" checked={newCrop.is_double_crop}
                                      onChange={(e) => setNewCrop({ ...newCrop, is_double_crop: e.target.checked })}
                                      className="w-4 h-4 rounded border-gray-300 text-amber-500 focus:ring-amber-500" />
                                    <span className="text-gray-700">Double Crop</span>
                                  </label>
                                )}
                              </div>
                              <div className="flex items-center gap-1 pt-4">
                                <button onClick={() => handleAddCrop(field.id)} disabled={saving}
                                  className="flex items-center gap-1 px-3 py-1.5 bg-green-600 text-white rounded text-sm hover:bg-green-700 disabled:opacity-50">
                                  <Icon name="check" size={14} /> Add
                                </button>
                                <button onClick={handleCancelAddCrop} className="p-1.5 text-gray-500 hover:bg-gray-100 rounded">
                                  <Icon name="x" size={16} />
                                </button>
                              </div>
                            </div>
                          </div>
                        )}

                        {/* Existing Crops Table */}
                        {fieldCrops.length > 0 && (
                          <table className="w-full text-sm">
                            <thead className="bg-gray-50">
                              <tr>
                                <th className="text-left px-2 py-2 font-medium text-gray-600">Crop</th>
                                <th className="text-right px-2 py-2 font-medium text-gray-600 w-20">Acres</th>
                                <th className="text-right px-2 py-2 font-medium text-gray-600 w-20">Yield</th>
                                <th className="text-right px-2 py-2 font-medium text-gray-600 w-28">Expected Bu</th>
                                <th className="text-right px-2 py-2 font-medium text-gray-600 w-24">Actual</th>
                                <th className="text-center px-2 py-2 font-medium text-gray-600 w-16">IR</th>
                                <th className="text-center px-2 py-2 font-medium text-gray-600 w-16">DC</th>
                                <th className="text-center px-2 py-2 font-medium text-gray-600 w-16"></th>
                              </tr>
                            </thead>
                            <tbody className="divide-y divide-gray-100">
                              {fieldCrops.map(crop => {
                                const cropIsCorn = crop.commodity_name === 'Corn';
                                return (
                                  <tr key={crop.id} className={crop.isModified ? 'bg-yellow-50' : ''}>
                                    <td className="px-2 py-2 font-medium text-gray-900">{crop.display_name}</td>
                                    <td className="px-2 py-2">
                                      <input type="number" step="0.1" value={crop.planted_acres || ''}
                                        onChange={(e) => handleCellChange(crop.id, 'planted_acres', parseFloat(e.target.value) || 0)}
                                        className="w-full px-2 py-1 text-right border border-gray-200 rounded focus:ring-1 focus:ring-amber-500" />
                                    </td>
                                    <td className="px-2 py-2">
                                      <input type="number" step="0.1" value={crop.estimated_yield || ''}
                                        onChange={(e) => handleCellChange(crop.id, 'estimated_yield', parseFloat(e.target.value) || 0)}
                                        className="w-full px-2 py-1 text-right border border-gray-200 rounded focus:ring-1 focus:ring-amber-500" />
                                    </td>
                                    <td className="px-2 py-2 text-right text-gray-600">{Math.round(crop.expected_marketable).toLocaleString()}</td>
                                    <td className="px-2 py-2">
                                      <input type="number" value={crop.actual_production ?? ''}
                                        onChange={(e) => handleCellChange(crop.id, 'actual_production', e.target.value ? parseInt(e.target.value) : null)}
                                        className="w-full px-2 py-1 text-right border border-gray-200 rounded focus:ring-1 focus:ring-amber-500" placeholder="-" />
                                    </td>
                                    <td className="px-2 py-2 text-center">
                                      <input type="checkbox" checked={crop.is_irrigated || false}
                                        onChange={(e) => handleCellChange(crop.id, 'is_irrigated', e.target.checked)}
                                        className="w-4 h-4 rounded border-gray-300 text-amber-500 focus:ring-amber-500" />
                                    </td>
                                    <td className="px-2 py-2 text-center">
                                      {!cropIsCorn ? (
                                        <input type="checkbox" checked={crop.is_double_crop || false}
                                          onChange={(e) => handleCellChange(crop.id, 'is_double_crop', e.target.checked)}
                                          className="w-4 h-4 rounded border-gray-300 text-amber-500 focus:ring-amber-500" />
                                      ) : (
                                        <span className="text-gray-300">-</span>
                                      )}
                                    </td>
                                    <td className="px-2 py-2 text-center">
                                      <button onClick={() => handleDelete(crop)} className="p-1 text-red-500 hover:bg-red-50 rounded">
                                        <Icon name="trash-2" size={14} />
                                      </button>
                                    </td>
                                  </tr>
                                );
                              })}
                            </tbody>
                          </table>
                        )}

                        {fieldCrops.length === 0 && !isAdding && (
                          <p className="text-sm text-gray-400 italic">No crops assigned for {cropYear}</p>
                        )}
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

// Insurance Page
function InsurancePage({ cropYear, onYearChange }) {
  const [commodities, setCommodities] = useState([]);
  const [rows, setRows] = useState([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [message, setMessage] = useState(null);
  const [practiceMode, setPracticeMode] = useState('commodity'); // 'commodity', 'irrigation', 'season'

  const currentYear = new Date().getFullYear();
  const cropYears = [currentYear - 1, currentYear, currentYear + 1, currentYear + 2];

  const loadData = async () => {
    setLoading(true);
    const [comms, settings] = await Promise.all([
      getCommodities(),
      getInsuranceSettings(cropYear)
    ]);
    setCommodities(comms);

    const allRows = [];

    if (practiceMode === 'commodity') {
      // One row per commodity
      for (const c of comms) {
        const existing = settings.find(s => s.commodity_id === c.id && !s.practice_type);
        allRows.push({
          commodity_id: c.id,
          commodity_name: c.name,
          practice_type: null,
          display_name: c.name,
          coverage_level: existing?.coverage_level || 0.75,
          price_election: existing?.price_election || 0,
          policy_type: existing?.policy_type || 'RP',
          notes: existing?.notes || '',
          isModified: false
        });
      }
    } else if (practiceMode === 'irrigation') {
      // Two rows per commodity: IR and DL
      for (const c of comms) {
        for (const practice of [{ type: 'IR', name: 'Irrigated' }, { type: 'DL', name: 'Dryland' }]) {
          const existing = settings.find(s => s.commodity_id === c.id && s.practice_type === practice.type);
          const fallback = settings.find(s => s.commodity_id === c.id && !s.practice_type);
          const setting = existing || fallback;
          allRows.push({
            commodity_id: c.id,
            commodity_name: c.name,
            practice_type: practice.type,
            display_name: `${c.name} ${practice.type}`,
            coverage_level: setting?.coverage_level || 0.75,
            price_election: setting?.price_election || 0,
            policy_type: setting?.policy_type || 'RP',
            notes: setting?.notes || '',
            isModified: false
          });
        }
      }
    } else if (practiceMode === 'season') {
      // Two rows per commodity (except Corn): FS and DC
      for (const c of comms) {
        if (c.name === 'Corn') {
          // Corn is always full season, just show one row
          const existing = settings.find(s => s.commodity_id === c.id && !s.practice_type);
          allRows.push({
            commodity_id: c.id,
            commodity_name: c.name,
            practice_type: null,
            display_name: c.name,
            coverage_level: existing?.coverage_level || 0.75,
            price_election: existing?.price_election || 0,
            policy_type: existing?.policy_type || 'RP',
            notes: existing?.notes || '',
            isModified: false
          });
        } else {
          for (const practice of [{ type: 'FS', name: 'Full Season' }, { type: 'DC', name: 'Double Crop' }]) {
            const existing = settings.find(s => s.commodity_id === c.id && s.practice_type === practice.type);
            const fallback = settings.find(s => s.commodity_id === c.id && !s.practice_type);
            const setting = existing || fallback;
            allRows.push({
              commodity_id: c.id,
              commodity_name: c.name,
              practice_type: practice.type,
              display_name: `${c.name} ${practice.type === 'DC' ? '(DC)' : ''}`.trim(),
              coverage_level: setting?.coverage_level || 0.75,
              price_election: setting?.price_election || 0,
              policy_type: setting?.policy_type || 'RP',
              notes: setting?.notes || '',
              isModified: false
            });
          }
        }
      }
    }

    setRows(allRows);
    setLoading(false);
  };

  useEffect(() => { loadData(); }, [cropYear, practiceMode]);

  const handleCellChange = (index, field, value) => {
    setRows(prev => {
      const newRows = [...prev];
      newRows[index] = { ...newRows[index], [field]: value, isModified: true };
      return newRows;
    });
  };

  const handleSave = async () => {
    setSaving(true);
    setMessage(null);

    const modifiedRows = rows.filter(r => r.isModified);
    let successCount = 0;
    let errorCount = 0;

    for (const row of modifiedRows) {
      const result = await upsertInsuranceSetting({
        crop_year: cropYear,
        commodity_id: row.commodity_id,
        practice_type: row.practice_type,
        coverage_level: row.coverage_level,
        price_election: row.price_election,
        policy_type: row.policy_type,
        notes: row.notes || null
      });
      if (result) successCount++; else errorCount++;
    }

    if (errorCount > 0) setMessage({ type: 'error', text: `Saved ${successCount} settings, ${errorCount} failed` });
    else if (successCount > 0) setMessage({ type: 'success', text: `Saved ${successCount} insurance settings` });

    await loadData();
    setSaving(false);
    setTimeout(() => setMessage(null), 3000);
  };

  const hasModifiedRows = rows.some(r => r.isModified);

  if (loading) return <div className="flex items-center justify-center h-64"><Icon name="refresh-cw" className="animate-spin text-amber-600" size={32} /></div>;

  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Insurance Settings</h1>
          <p className="text-sm text-gray-500 mt-1">Configure crop insurance coverage levels</p>
        </div>
        <div className="flex items-center gap-3">
          <select value={cropYear} onChange={(e) => onYearChange(parseInt(e.target.value))}
            className="px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium focus:ring-2 focus:ring-amber-500">
            {cropYears.map(year => <option key={year} value={year}>{year} Crop Year</option>)}
          </select>
          <button onClick={handleSave} disabled={!hasModifiedRows || saving}
            className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium ${
              hasModifiedRows ? 'bg-amber-500 text-white hover:bg-amber-600' : 'bg-gray-100 text-gray-400 cursor-not-allowed'}`}>
            {saving ? <Icon name="refresh-cw" className="animate-spin" size={16} /> : <Icon name="save" size={16} />}
            Save
          </button>
        </div>
      </div>

      {message && (
        <div className={`px-4 py-3 rounded-lg flex items-center gap-2 text-sm ${
          message.type === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
          <Icon name={message.type === 'success' ? 'check' : 'x'} size={16} />
          {message.text}
        </div>
      )}

      {/* Practice Mode Toggle */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-4">
        <div className="flex items-center gap-4 flex-wrap">
          <Icon name="layers" size={16} className="text-gray-500" />
          <span className="text-sm font-medium text-gray-700">Coverage By:</span>
          <div className="flex rounded-lg border border-gray-200 overflow-hidden">
            <button onClick={() => setPracticeMode('commodity')}
              className={`px-3 py-1.5 text-sm font-medium transition-colors ${
                practiceMode === 'commodity' ? 'bg-blue-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-50'}`}>
              Commodity Only
            </button>
            <button onClick={() => setPracticeMode('irrigation')}
              className={`px-3 py-1.5 text-sm font-medium transition-colors border-l border-gray-200 ${
                practiceMode === 'irrigation' ? 'bg-blue-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-50'}`}>
              By Irrigation (IR/DL)
            </button>
            <button onClick={() => setPracticeMode('season')}
              className={`px-3 py-1.5 text-sm font-medium transition-colors border-l border-gray-200 ${
                practiceMode === 'season' ? 'bg-blue-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-50'}`}>
              By Season (FS/DC)
            </button>
          </div>
        </div>
      </div>

      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 text-sm text-blue-800">
        <p><strong>Insurance Production</strong> is calculated as: Expected Production x Coverage Level</p>
        <p className="mt-1">Choose how you want to configure coverage: by commodity only, by irrigation practice, or by season type.</p>
        {practiceMode !== 'commodity' && (
          <p className="mt-2 text-blue-600"><strong>Note:</strong> You can only insure by ONE dimension (irrigation OR season), not both combined.</p>
        )}
      </div>

      <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
        <div className="overflow-x-auto">
          <table className="w-full text-sm">
            <thead className="bg-gray-50 border-b border-gray-200">
              <tr>
                <th className="text-left px-4 py-3 font-semibold text-gray-700">
                  {practiceMode === 'commodity' ? 'Commodity' : 'Commodity / Practice'}
                </th>
                <th className="text-center px-4 py-3 font-semibold text-gray-700 w-32">Coverage Level</th>
                <th className="text-right px-4 py-3 font-semibold text-gray-700 w-32">Price Election</th>
                <th className="text-center px-4 py-3 font-semibold text-gray-700 w-28">Policy Type</th>
                <th className="text-left px-4 py-3 font-semibold text-gray-700">Notes</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-100">
              {rows.map((row, index) => (
                <tr key={`${row.commodity_id}-${row.practice_type || 'all'}`} className={row.isModified ? 'bg-yellow-50' : ''}>
                  <td className="px-4 py-3">
                    <div className="flex items-center gap-2">
                      <Icon name="shield" size={16} className="text-amber-500" />
                      <span className="font-medium text-gray-900">{row.display_name}</span>
                    </div>
                  </td>
                  <td className="px-2 py-3">
                    <select value={row.coverage_level} onChange={(e) => handleCellChange(index, 'coverage_level', parseFloat(e.target.value))}
                      className="w-full px-2 py-1.5 border border-gray-300 rounded text-center focus:ring-2 focus:ring-amber-500">
                      {[0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85].map(v => (
                        <option key={v} value={v}>{(v * 100).toFixed(0)}%</option>
                      ))}
                    </select>
                  </td>
                  <td className="px-2 py-3">
                    <div className="flex items-center">
                      <span className="text-gray-500 mr-1">$</span>
                      <input type="number" step="0.01" value={row.price_election || ''}
                        onChange={(e) => handleCellChange(index, 'price_election', parseFloat(e.target.value) || 0)}
                        className="w-full px-2 py-1.5 text-right border border-gray-300 rounded focus:ring-2 focus:ring-amber-500" placeholder="0.00" />
                    </div>
                  </td>
                  <td className="px-2 py-3">
                    <select value={row.policy_type} onChange={(e) => handleCellChange(index, 'policy_type', e.target.value)}
                      className="w-full px-2 py-1.5 border border-gray-300 rounded text-center focus:ring-2 focus:ring-amber-500">
                      <option value="RP">RP</option>
                      <option value="RP-HPE">RP-HPE</option>
                      <option value="YP">YP</option>
                    </select>
                  </td>
                  <td className="px-2 py-3">
                    <input type="text" value={row.notes} onChange={(e) => handleCellChange(index, 'notes', e.target.value)}
                      className="w-full px-2 py-1.5 border border-gray-300 rounded focus:ring-2 focus:ring-amber-500" placeholder="Notes..." />
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Delete Confirmation Modal */}
      <ConfirmModal
        isOpen={!!confirmDelete}
        title="Delete Crop"
        message={confirmDelete ? `Are you sure you want to delete ${confirmDelete.display_name} on ${confirmDelete.field_name}?` : ''}
        confirmText="Delete"
        cancelText="Cancel"
        variant="danger"
        onConfirm={confirmDeleteProduction}
        onCancel={() => setConfirmDelete(null)}
      />
    </div>
  );
}

// Buyers Page
function BuyersPage() {
  const [buyers, setBuyers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [newBuyerName, setNewBuyerName] = useState('');
  const [editingId, setEditingId] = useState(null);
  const [editingName, setEditingName] = useState('');
  const [confirmDelete, setConfirmDelete] = useState(null);
  const { addToast } = useToast();

  const loadData = async () => {
    setLoading(true);
    const data = await getBuyers(true);
    setBuyers(data);
    setLoading(false);
  };

  useEffect(() => { loadData(); }, []);

  const handleAdd = async () => {
    if (!newBuyerName.trim()) return;
    try {
      await createBuyer(newBuyerName.trim());
      setNewBuyerName('');
      loadData();
    } catch (e) { console.error(e); }
  };

  const handleUpdate = async (id) => {
    if (!editingName.trim()) return;
    try {
      await updateBuyer(id, { name: editingName.trim() });
      setEditingId(null);
      loadData();
    } catch (e) { console.error(e); }
  };

  const handleToggleActive = async (id, active) => {
    try {
      await updateBuyer(id, { active: !active });
      loadData();
    } catch (e) { console.error(e); }
  };

  const handleDelete = (buyer) => {
    setConfirmDelete(buyer);
  };

  const confirmDeleteBuyer = async () => {
    const buyer = confirmDelete;
    setConfirmDelete(null);

    try {
      const oldRecord = await deleteBuyer(buyer.id);
      loadData();
      addToast(`Deleted buyer: ${buyer.name}`, {
        type: 'warning',
        undoAction: async () => {
          await restoreRecord('buyers', buyer.id);
          await logAudit('buyers', buyer.id, 'RESTORE', null, oldRecord);
          loadData();
          addToast('Buyer restored', { type: 'success' });
        }
      });
    } catch (e) {
      console.error(e);
      addToast('Failed to delete buyer', { type: 'error' });
    }
  };

  if (loading) return <div className="flex items-center justify-center h-64"><Icon name="refresh-cw" className="animate-spin text-amber-600" size={32} /></div>;

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-bold text-gray-900">Buyers</h1>
        <p className="text-sm text-gray-500 mt-1">Manage grain buyers and elevators</p>
      </div>

      {/* Add new buyer */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-4">
        <div className="flex items-center gap-3">
          <input type="text" value={newBuyerName} onChange={(e) => setNewBuyerName(e.target.value)}
            placeholder="New buyer name..." onKeyPress={(e) => e.key === 'Enter' && handleAdd()}
            className="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
          <button onClick={handleAdd} className="px-4 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600 flex items-center gap-2">
            <Icon name="plus" size={16} /> Add Buyer
          </button>
        </div>
      </div>

      {/* Buyers list */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
        <table className="w-full text-sm">
          <thead className="bg-gray-50 border-b border-gray-200">
            <tr>
              <th className="text-left px-4 py-3 font-semibold text-gray-700">Name</th>
              <th className="text-center px-4 py-3 font-semibold text-gray-700 w-24">Status</th>
              <th className="text-center px-4 py-3 font-semibold text-gray-700 w-32">Actions</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-100">
            {buyers.map(buyer => (
              <tr key={buyer.id} className={!buyer.active ? 'bg-gray-50' : ''}>
                <td className="px-4 py-3">
                  {editingId === buyer.id ? (
                    <div className="flex items-center gap-2">
                      <input type="text" value={editingName} onChange={(e) => setEditingName(e.target.value)}
                        className="flex-1 px-2 py-1 border border-gray-300 rounded focus:ring-2 focus:ring-amber-500" autoFocus />
                      <button onClick={() => handleUpdate(buyer.id)} className="text-green-600"><Icon name="check" size={16} /></button>
                      <button onClick={() => setEditingId(null)} className="text-gray-400"><Icon name="x" size={16} /></button>
                    </div>
                  ) : (
                    <span className={`font-medium ${buyer.active ? 'text-gray-900' : 'text-gray-400'}`}>{buyer.name}</span>
                  )}
                </td>
                <td className="px-4 py-3 text-center">
                  <span className={`px-2 py-1 rounded text-xs font-medium ${
                    buyer.active ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-500'}`}>
                    {buyer.active ? 'Active' : 'Inactive'}
                  </span>
                </td>
                <td className="px-4 py-3 text-center">
                  <div className="flex items-center justify-center gap-1">
                    <button onClick={() => { setEditingId(buyer.id); setEditingName(buyer.name); }}
                      className="p-1.5 text-blue-500 hover:bg-blue-50 rounded" title="Edit">
                      <Icon name="pencil" size={16} />
                    </button>
                    <button onClick={() => handleToggleActive(buyer.id, buyer.active)}
                      className={`p-1.5 rounded ${buyer.active ? 'text-gray-500 hover:bg-gray-100' : 'text-green-500 hover:bg-green-50'}`}
                      title={buyer.active ? 'Deactivate' : 'Activate'}>
                      <Icon name={buyer.active ? 'eye-off' : 'eye'} size={16} />
                    </button>
                    <button onClick={() => handleDelete(buyer)} className="p-1.5 text-red-500 hover:bg-red-50 rounded" title="Delete">
                      <Icon name="trash-2" size={16} />
                    </button>
                  </div>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {buyers.length === 0 && (
          <div className="p-8 text-center text-gray-500">No buyers configured</div>
        )}
      </div>

      {/* Delete Confirmation Modal */}
      <ConfirmModal
        isOpen={!!confirmDelete}
        title="Delete Buyer"
        message={confirmDelete ? `Are you sure you want to delete "${confirmDelete.name}"?` : ''}
        confirmText="Delete"
        cancelText="Cancel"
        variant="danger"
        onConfirm={confirmDeleteBuyer}
        onCancel={() => setConfirmDelete(null)}
      />
    </div>
  );
}

// Storage Page
function StoragePage() {
  const [locations, setLocations] = useState([]);
  const [buyers, setBuyers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [showForm, setShowForm] = useState(false);
  const [editingLocation, setEditingLocation] = useState({ name: '', location_type: 'COMMERCIAL', is_storage: true, is_delivery: true, notes: '', buyer_ids: [] });
  const [isEditing, setIsEditing] = useState(false);
  const [showInactive, setShowInactive] = useState(false);

  const loadData = async () => {
    setLoading(true);
    const [locs, buys] = await Promise.all([getGrainLocations(true), getBuyers()]);
    setLocations(locs);
    setBuyers(buys);
    setLoading(false);
  };

  useEffect(() => { loadData(); }, []);

  const handleSave = async () => {
    if (!editingLocation.name.trim()) return;
    
    if (isEditing && editingLocation.id) {
      await updateGrainLocation(editingLocation.id, {
        name: editingLocation.name.trim(),
        location_type: editingLocation.location_type,
        is_storage: editingLocation.is_storage,
        is_delivery: editingLocation.is_delivery,
        notes: editingLocation.notes.trim() || null
      });
      await setLocationBuyers(editingLocation.id, editingLocation.buyer_ids);
    } else {
      const newLoc = await createGrainLocation({
        name: editingLocation.name.trim(),
        location_type: editingLocation.location_type,
        is_storage: editingLocation.is_storage,
        is_delivery: editingLocation.is_delivery,
        notes: editingLocation.notes.trim() || null
      });
      if (newLoc && editingLocation.buyer_ids.length > 0) {
        await setLocationBuyers(newLoc.id, editingLocation.buyer_ids);
      }
    }
    
    setShowForm(false);
    setEditingLocation({ name: '', location_type: 'COMMERCIAL', is_storage: true, is_delivery: true, notes: '', buyer_ids: [] });
    setIsEditing(false);
    loadData();
  };

  const handleEdit = (loc) => {
    setEditingLocation({
      id: loc.id,
      name: loc.name,
      location_type: loc.location_type,
      is_storage: loc.is_storage,
      is_delivery: loc.is_delivery,
      notes: loc.notes || '',
      buyer_ids: loc.buyers?.map(b => b.buyer_id) || []
    });
    setIsEditing(true);
    setShowForm(true);
  };

  const handleToggleActive = async (id, active) => {
    await toggleGrainLocationActive(id, !active);
    loadData();
  };

  const handleDelete = async (id) => {
    if (!confirm('Delete this location?')) return;
    await deleteGrainLocation(id);
    loadData();
  };

  const filteredLocations = showInactive ? locations : locations.filter(l => l.active);

  if (loading) return <div className="flex items-center justify-center h-64"><Icon name="refresh-cw" className="animate-spin text-amber-600" size={32} /></div>;

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Storage Locations</h1>
          <p className="text-sm text-gray-500 mt-1">Manage grain storage and delivery locations</p>
        </div>
        <button onClick={() => { setShowForm(true); setIsEditing(false); setEditingLocation({ name: '', location_type: 'COMMERCIAL', is_storage: true, is_delivery: true, notes: '', buyer_ids: [] }); }}
          className="px-4 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600 flex items-center gap-2">
          <Icon name="plus" size={16} /> Add Location
        </button>
      </div>

      <label className="flex items-center gap-2 text-sm">
        <input type="checkbox" checked={showInactive} onChange={(e) => setShowInactive(e.target.checked)}
          className="w-4 h-4 rounded border-gray-300 text-amber-500" />
        Show inactive locations
      </label>

      {/* Add/Edit Form */}
      {showForm && (
        <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
          <h3 className="text-lg font-semibold mb-4">{isEditing ? 'Edit Location' : 'Add New Location'}</h3>
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Name *</label>
              <input type="text" value={editingLocation.name} onChange={(e) => setEditingLocation({ ...editingLocation, name: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Type</label>
              <select value={editingLocation.location_type} onChange={(e) => setEditingLocation({ ...editingLocation, location_type: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500">
                <option value="ON_FARM">On-Farm Bin</option>
                <option value="COMMERCIAL">Commercial Elevator</option>
                <option value="DELIVERY">Delivery Only</option>
              </select>
            </div>
            <div className="flex items-center gap-6">
              <label className="flex items-center gap-2">
                <input type="checkbox" checked={editingLocation.is_storage} onChange={(e) => setEditingLocation({ ...editingLocation, is_storage: e.target.checked })}
                  className="w-4 h-4 rounded border-gray-300 text-amber-500" />
                <span className="text-sm">Can store grain</span>
              </label>
              <label className="flex items-center gap-2">
                <input type="checkbox" checked={editingLocation.is_delivery} onChange={(e) => setEditingLocation({ ...editingLocation, is_delivery: e.target.checked })}
                  className="w-4 h-4 rounded border-gray-300 text-amber-500" />
                <span className="text-sm">Can deliver to</span>
              </label>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Notes</label>
              <textarea value={editingLocation.notes} onChange={(e) => setEditingLocation({ ...editingLocation, notes: e.target.value })}
                rows={2} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500" />
            </div>
            <div className="flex justify-end gap-3">
              <button onClick={() => { setShowForm(false); setIsEditing(false); }} className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-lg">Cancel</button>
              <button onClick={handleSave} className="px-4 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600">
                {isEditing ? 'Update' : 'Create'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Locations list */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
        <table className="w-full text-sm">
          <thead className="bg-gray-50 border-b border-gray-200">
            <tr>
              <th className="text-left px-4 py-3 font-semibold text-gray-700">Name</th>
              <th className="text-center px-4 py-3 font-semibold text-gray-700 w-28">Type</th>
              <th className="text-center px-4 py-3 font-semibold text-gray-700 w-20">Storage</th>
              <th className="text-center px-4 py-3 font-semibold text-gray-700 w-20">Delivery</th>
              <th className="text-center px-4 py-3 font-semibold text-gray-700 w-32">Actions</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-100">
            {filteredLocations.map(loc => (
              <tr key={loc.id} className={!loc.active ? 'bg-gray-50' : ''}>
                <td className="px-4 py-3">
                  <span className={`font-medium ${loc.active ? 'text-gray-900' : 'text-gray-400'}`}>{loc.name}</span>
                </td>
                <td className="px-4 py-3 text-center">
                  <span className={`px-2 py-1 rounded text-xs font-medium ${
                    loc.location_type === 'ON_FARM' ? 'bg-green-100 text-green-700' :
                    loc.location_type === 'COMMERCIAL' ? 'bg-blue-100 text-blue-700' :
                    'bg-purple-100 text-purple-700'
                  }`}>{loc.location_type.replace('_', ' ')}</span>
                </td>
                <td className="px-4 py-3 text-center">{loc.is_storage ? <Icon name="check" size={16} className="text-green-500 mx-auto" /> : '-'}</td>
                <td className="px-4 py-3 text-center">{loc.is_delivery ? <Icon name="check" size={16} className="text-green-500 mx-auto" /> : '-'}</td>
                <td className="px-4 py-3 text-center">
                  <div className="flex items-center justify-center gap-1">
                    <button onClick={() => handleEdit(loc)} className="p-1.5 text-blue-500 hover:bg-blue-50 rounded" title="Edit">
                      <Icon name="pencil" size={16} />
                    </button>
                    <button onClick={() => handleToggleActive(loc.id, loc.active)}
                      className={`p-1.5 rounded ${loc.active ? 'text-gray-500 hover:bg-gray-100' : 'text-green-500 hover:bg-green-50'}`}
                      title={loc.active ? 'Deactivate' : 'Activate'}>
                      <Icon name={loc.active ? 'eye-off' : 'eye'} size={16} />
                    </button>
                    <button onClick={() => handleDelete(loc.id)} className="p-1.5 text-red-500 hover:bg-red-50 rounded" title="Delete">
                      <Icon name="trash-2" size={16} />
                    </button>
                  </div>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {filteredLocations.length === 0 && <div className="p-8 text-center text-gray-500">No locations configured</div>}
      </div>
    </div>
  );
}

// Basis Management Page
function BasisPage() {
  const [viewMode, setViewMode] = useState('old'); // 'old' or 'new'
  const [commodities, setCommodities] = useState([]);
  const [locations, setLocations] = useState([]);
  const [basisData, setBasisData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState({});
  const [message, setMessage] = useState(null);
  const [localValues, setLocalValues] = useState({});

  // Commodity-specific rollover dates (month is 0-indexed)
  const CROP_ROLLOVER = {
    'Wheat': { month: 5, day: 1 },      // June 1
    'Corn': { month: 8, day: 1 },       // Sept 1
    'Soybeans': { month: 9, day: 1 },   // Oct 1
    'Milo': { month: 9, day: 1 },       // Oct 1
    'Grain Sorghum': { month: 9, day: 1 }
  };

  const getCropYear = (commodityName, isNewCrop) => {
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth();
    const currentDay = now.getDate();
    
    const rollover = CROP_ROLLOVER[commodityName] || { month: 9, day: 1 };
    const hasRolled = currentMonth > rollover.month || 
                      (currentMonth === rollover.month && currentDay >= rollover.day);
    
    if (isNewCrop) {
      return hasRolled ? currentYear + 1 : currentYear;
    } else {
      return hasRolled ? currentYear : currentYear - 1;
    }
  };

  const loadData = async () => {
    setLoading(true);
    const [comms, locs] = await Promise.all([
      getCommodities(),
      getGrainLocations(false)
    ]);
    setCommodities(comms);
    setLocations(locs);
    
    // Load basis for all relevant crop years
    const years = new Set();
    for (const c of comms) {
      years.add(getCropYear(c.name, false));
      years.add(getCropYear(c.name, true));
    }
    
    const allBasis = [];
    for (const year of years) {
      const basis = await getLocationBasis(year);
      allBasis.push(...basis);
    }
    setBasisData(allBasis);
    
    const initial = {};
    for (const b of allBasis) {
      initial[`${b.location_id}-${b.commodity_id}-${b.crop_year}`] = b.basis?.toString() || '';
    }
    setLocalValues(initial);
    setLoading(false);
  };

  useEffect(() => { loadData(); }, []);

  const basisMap = {};
  for (const b of basisData) {
    basisMap[`${b.location_id}-${b.commodity_id}-${b.crop_year}`] = b;
  }

  const handleInputChange = (locationId, commodityId, cropYear, value) => {
    const key = `${locationId}-${commodityId}-${cropYear}`;
    setLocalValues(prev => ({ ...prev, [key]: value }));
  };

  const handleSave = async (locationId, commodityId, cropYear) => {
    const key = `${locationId}-${commodityId}-${cropYear}`;
    const value = localValues[key];
    const numValue = parseFloat(value);
    
    if (value === '' || isNaN(numValue)) {
      const existing = basisMap[key];
      if (existing?.id) {
        setSaving(prev => ({ ...prev, [key]: true }));
        try {
          await deleteLocationBasis(existing.id);
          setMessage({ type: 'success', text: 'Cleared' });
          loadData();
        } catch (e) {
          setMessage({ type: 'error', text: 'Failed' });
        }
        setSaving(prev => ({ ...prev, [key]: false }));
      }
      return;
    }
    
    setSaving(prev => ({ ...prev, [key]: true }));
    try {
      await upsertLocationBasis(locationId, commodityId, cropYear, numValue);
      setMessage({ type: 'success', text: 'Saved' });
      setTimeout(() => setMessage(null), 1500);
      loadData();
    } catch (e) {
      setMessage({ type: 'error', text: 'Failed' });
    }
    setSaving(prev => ({ ...prev, [key]: false }));
  };

  const getInputValue = (locationId, commodityId, cropYear) => {
    const key = `${locationId}-${commodityId}-${cropYear}`;
    if (localValues[key] !== undefined) return localValues[key];
    const existing = basisMap[key];
    return existing?.basis?.toString() || '';
  };

  if (loading) return <div className="flex items-center justify-center h-64"><Icon name="refresh-cw" className="animate-spin text-amber-600" size={32} /></div>;

  const isNewCrop = viewMode === 'new';

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between flex-wrap gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Basis Management</h1>
          <p className="text-sm text-gray-500 mt-1">Enter basis. Tab or click out to save.</p>
        </div>
        
        <div className="flex rounded-lg overflow-hidden border border-gray-300">
          <button
            onClick={() => setViewMode('old')}
            className={`px-4 py-2 text-sm font-medium ${
              viewMode === 'old' ? 'bg-amber-500 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'
            }`}
          >
            [Old] Old Crop
          </button>
          <button
            onClick={() => setViewMode('new')}
            className={`px-4 py-2 text-sm font-medium border-l border-gray-300 ${
              viewMode === 'new' ? 'bg-green-500 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'
            }`}
          >
            [New] New Crop
          </button>
        </div>
      </div>

      {message && (
        <div className={`p-3 rounded-lg text-sm ${message.type === 'error' ? 'bg-red-50 text-red-700' : 'bg-green-50 text-green-700'}`}>
          {message.text}
        </div>
      )}

      <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
        <div className={`p-3 border-b ${isNewCrop ? 'bg-green-50 border-green-200' : 'bg-amber-50 border-amber-200'}`}>
          <span className={`font-semibold ${isNewCrop ? 'text-green-700' : 'text-amber-700'}`}>
            {isNewCrop ? '[New] New Crop' : '[Old] Old Crop'} Basis
          </span>
          <span className="text-gray-500 text-sm ml-2">
            {isNewCrop ? '(upcoming harvest)' : '(harvested grain)'}
          </span>
        </div>
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 border-b border-gray-200">
              <tr>
                <th className="text-left px-4 py-3 font-semibold text-gray-700 text-sm">Location</th>
                {commodities.map(c => {
                  const cropYear = getCropYear(c.name, isNewCrop);
                  return (
                    <th key={c.id} className="text-center px-3 py-2 font-semibold text-gray-700 text-sm min-w-24">
                      <div>{c.name}</div>
                      <div className="text-xs font-normal text-gray-400">{cropYear}</div>
                    </th>
                  );
                })}
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-100">
              {locations.filter(l => l.is_delivery).map(loc => (
                <tr key={loc.id} className="hover:bg-gray-50">
                  <td className="px-4 py-3 font-medium text-gray-900 text-sm whitespace-nowrap">{loc.name}</td>
                  {commodities.map(c => {
                    const cropYear = getCropYear(c.name, isNewCrop);
                    const key = `${loc.id}-${c.id}-${cropYear}`;
                    const isSaving = saving[key];
                    
                    return (
                      <td key={c.id} className="px-3 py-2 text-center">
                        <input
                          type="number"
                          step="0.01"
                          placeholder="-0.00"
                          value={getInputValue(loc.id, c.id, cropYear)}
                          onChange={(e) => handleInputChange(loc.id, c.id, cropYear, e.target.value)}
                          onBlur={() => handleSave(loc.id, c.id, cropYear)}
                          onKeyDown={(e) => { if (e.key === 'Enter') e.target.blur(); }}
                          disabled={isSaving}
                          className={`w-20 px-2 py-1.5 text-center text-sm border rounded 
                            focus:ring-2 focus:ring-amber-500 focus:border-amber-500
                            ${isSaving ? 'bg-gray-100 text-gray-400' : 'bg-white'}
                            ${getInputValue(loc.id, c.id, cropYear) ? 'border-gray-300 font-medium' : 'border-gray-200 text-gray-400'}
                          `}
                        />
                      </td>
                    );
                  })}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
        
        {locations.filter(l => l.is_delivery).length === 0 && (
          <div className="p-8 text-center text-gray-500">No delivery locations. Add in Storage page.</div>
        )}
      </div>

      <div className="text-xs text-gray-400">
        Crop year rolls: Wheat Jun 1 * Corn Sep 1 * Soybeans Oct 1 * Milo Oct 1
      </div>
    </div>
  );
}

// Inventory Page
function InventoryPage({ cropYear, onYearChange }) {
  const [inventory, setInventory] = useState([]);
  const [transactions, setTransactions] = useState({});
  const [expandedRows, setExpandedRows] = useState(new Set());
  const [loading, setLoading] = useState(true);
  const [commodities, setCommodities] = useState([]);
  const [locations, setLocations] = useState([]);
  const [elevatorMappings, setElevatorMappings] = useState([]);
  const [message, setMessage] = useState(null);
  
  // Modal states
  const [showPoyModal, setShowPoyModal] = useState(false);
  const [showAdjustModal, setShowAdjustModal] = useState(false);
  const [showTransferModal, setShowTransferModal] = useState(false);
  const [showAddGrainModal, setShowAddGrainModal] = useState(false);
  
  // POY Import state
  const [poyFile, setPoyFile] = useState(null);
  const [poyParsing, setPoyParsing] = useState(false);
  const [poyData, setPoyData] = useState(null);
  const [poyError, setPoyError] = useState(null);
  const [poyMappings, setPoyMappings] = useState({});
  const [poyDuplicates, setPoyDuplicates] = useState([]);
  const [poyImporting, setPoyImporting] = useState(false);
  
  // Adjustment state
  const [adjustForm, setAdjustForm] = useState({
    location_id: '', commodity_id: '', adjustment_type: 'SHRINK',
    bushels: '', reason: '', transaction_date: new Date().toISOString().split('T')[0]
  });
  
  // Transfer state
  const [transferForm, setTransferForm] = useState({
    transfer_type: 'SINGLE', // SINGLE or SWAP
    from_location_id: '', to_location_id: '',
    commodity_id: '', bushels: '', counterparty: '',
    notes: '', transaction_date: new Date().toISOString().split('T')[0]
  });
  
  // Add Grain state
  const [addGrainForm, setAddGrainForm] = useState({
    location_id: '', commodity_id: '', bushels: '',
    transaction_date: new Date().toISOString().split('T')[0], notes: ''
  });

  const currentYear = new Date().getFullYear();
  const cropYears = [currentYear - 1, currentYear, currentYear + 1, currentYear + 2];

  const loadData = useCallback(async () => {
    setLoading(true);
    const [inv, comms, locs, mappings] = await Promise.all([
      getInventory(cropYear),
      getCommodities(),
      getStorageLocations(),
      getElevatorMappings()
    ]);
    setInventory(inv);
    setCommodities(comms);
    setLocations(locs);
    setElevatorMappings(mappings);
    setLoading(false);
  }, [cropYear]);

  useEffect(() => { loadData(); }, [loadData]);

  const loadTransactions = async (locationId, commodityId) => {
    const key = `${locationId}-${commodityId}`;
    if (transactions[key]) return; // Already loaded
    
    const data = await getInventoryTransactions(locationId, commodityId, cropYear);
    setTransactions(prev => ({ ...prev, [key]: data }));
  };

  const toggleRow = async (item) => {
    const key = `${item.location_id}-${item.commodity_id}`;
    const newExpanded = new Set(expandedRows);
    
    if (newExpanded.has(key)) {
      newExpanded.delete(key);
    } else {
      newExpanded.add(key);
      await loadTransactions(item.location_id, item.commodity_id);
    }
    setExpandedRows(newExpanded);
  };

  const showMsg = (type, text) => {
    setMessage({ type, text });
    setTimeout(() => setMessage(null), 4000);
  };

  // ========== POY IMPORT HANDLERS ==========
  
  const handlePoyFileSelect = (e) => {
    const file = e.target.files[0];
    if (file) {
      setPoyFile(file);
      setPoyData(null);
      setPoyError(null);
      setPoyMappings({});
      setPoyDuplicates([]);
    }
  };

  const handlePoyParse = async () => {
    if (!poyFile) return;
    
    setPoyParsing(true);
    setPoyError(null);
    
    try {
      const base64 = await fileToBase64(poyFile);
      const mimeType = poyFile.type || 'application/pdf';
      
      const result = await parsePoYWithClaude(base64, mimeType);
      
      if (!result.success) {
        setPoyError(result.error);
        setPoyParsing(false);
        return;
      }
      
      setPoyData(result.data);
      
      // Check for duplicate tickets
      const ticketNumbers = result.data.deliveries?.map(d => d.ticket_number) || [];
      const existingTickets = await checkExistingTickets(ticketNumbers);
      setPoyDuplicates(existingTickets);
      
      // Initialize mappings from existing elevator mappings
      const initialMappings = {};
      const uniqueLocations = [...new Set(result.data.deliveries?.map(d => d.location) || [])];
      
      for (const loc of uniqueLocations) {
        const existing = elevatorMappings.find(m => m.elevator_name.toLowerCase() === loc.toLowerCase());
        if (existing) {
          initialMappings[loc] = existing.location_id;
        }
      }
      setPoyMappings(initialMappings);
      
    } catch (err) {
      setPoyError(err.message);
    }
    
    setPoyParsing(false);
  };

  const handlePoyImport = async () => {
    if (!poyData) return;
    
    // Check all locations are mapped
    const uniqueLocations = [...new Set(poyData.deliveries?.map(d => d.location) || [])];
    const unmapped = uniqueLocations.filter(loc => !poyMappings[loc]);
    if (unmapped.length > 0) {
      showMsg('error', `Please map all locations: ${unmapped.join(', ')}`);
      return;
    }
    
    setPoyImporting(true);
    
    try {
      // Filter out duplicates
      const newDeliveries = poyData.deliveries.filter(d => !poyDuplicates.includes(d.ticket_number));
      
      if (newDeliveries.length === 0) {
        showMsg('error', 'All tickets have already been imported');
        setPoyImporting(false);
        return;
      }
      
      // Create import record
      const importRecord = await createPoyImport({
        file_name: poyFile.name,
        crop_year: poyData.crop_year,
        producer_name: poyData.producer_name,
        total_bushels_imported: newDeliveries.reduce((sum, d) => sum + d.your_bushels, 0),
        total_tickets_imported: newDeliveries.length,
        tickets_skipped: poyDuplicates.length,
        commodities_imported: [...new Set(newDeliveries.map(d => d.commodity))],
        locations_imported: [...new Set(newDeliveries.map(d => d.location))],
        raw_response: poyData
      });
      
      if (!importRecord) {
        throw new Error('Failed to create import record');
      }
      
      // Group deliveries by date + location + commodity
      const grouped = {};
      for (const delivery of newDeliveries) {
        const key = `${delivery.date}|${delivery.location}|${delivery.commodity}`;
        if (!grouped[key]) {
          grouped[key] = {
            date: delivery.date,
            location: delivery.location,
            commodity: delivery.commodity,
            total_bushels: 0,
            tickets: []
          };
        }
        grouped[key].total_bushels += delivery.your_bushels;
        grouped[key].tickets.push(delivery);
      }
      
      // Create inventory transactions for each group
      for (const group of Object.values(grouped)) {
        const locationId = poyMappings[group.location];
        const commodity = commodities.find(c => c.name.toLowerCase() === group.commodity.toLowerCase());
        
        if (!commodity) {
          console.warn(`Unknown commodity: ${group.commodity}`);
          continue;
        }
        
        const ticketNumbers = group.tickets.map(t => t.ticket_number).join(', ');
        
        await recordInventoryChange(
          locationId,
          commodity.id,
          poyData.crop_year,
          Math.round(group.total_bushels),
          'DEPOSIT',
          {
            transaction_date: group.date,
            ticket_numbers: ticketNumbers,
            import_id: importRecord.id,
            notes: `POY Import: ${group.tickets.length} tickets`
          }
        );
        
        // Record individual tickets for duplicate detection
        for (const ticket of group.tickets) {
          await recordImportedTicket({
            ticket_number: ticket.ticket_number,
            import_id: importRecord.id,
            delivery_date: ticket.date,
            commodity_id: commodity.id,
            location_id: locationId,
            bushels: ticket.your_bushels,
            elevator_name: ticket.location
          });
        }
      }
      
      // Save any new elevator mappings
      for (const [elevatorName, locationId] of Object.entries(poyMappings)) {
        const exists = elevatorMappings.find(m => m.elevator_name.toLowerCase() === elevatorName.toLowerCase());
        if (!exists) {
          await createElevatorMapping(elevatorName, locationId);
        }
      }
      
      showMsg('success', `Imported ${newDeliveries.length} tickets (${poyDuplicates.length} skipped as duplicates)`);
      setShowPoyModal(false);
      setPoyFile(null);
      setPoyData(null);
      setPoyMappings({});
      setPoyDuplicates([]);
      await loadData();
      setTransactions({}); // Clear cached transactions
      setExpandedRows(new Set());
      
    } catch (err) {
      console.error('Import error:', err);
      showMsg('error', `Import failed: ${err.message}`);
    }
    
    setPoyImporting(false);
  };

  // ========== ADJUSTMENT HANDLERS ==========
  
  const handleAdjustSubmit = async () => {
    const { location_id, commodity_id, adjustment_type, bushels, reason, transaction_date } = adjustForm;
    
    if (!location_id || !commodity_id || !bushels || !reason) {
      showMsg('error', 'Please fill in all required fields');
      return;
    }
    
    const bushelsNum = parseFloat(bushels);
    if (isNaN(bushelsNum) || bushelsNum <= 0) {
      showMsg('error', 'Please enter a valid bushel amount');
      return;
    }
    
    // Shrink is always negative, reconciliation can be positive or negative
    const adjustedBushels = adjustment_type === 'SHRINK' ? -Math.abs(bushelsNum) : bushelsNum;
    
    const result = await recordInventoryChange(
      location_id,
      commodity_id,
      cropYear,
      adjustedBushels,
      adjustment_type,
      {
        transaction_date,
        reason,
        notes: adjustment_type === 'SHRINK' ? `Shrink: ${Math.abs(bushelsNum).toLocaleString()} bu` : `Reconciliation: ${bushelsNum > 0 ? '+' : ''}${bushelsNum.toLocaleString()} bu`
      }
    );
    
    if (result) {
      showMsg('success', `${adjustment_type === 'SHRINK' ? 'Shrink' : 'Reconciliation'} recorded successfully`);
      setShowAdjustModal(false);
      setAdjustForm({
        location_id: '', commodity_id: '', adjustment_type: 'SHRINK',
        bushels: '', reason: '', transaction_date: new Date().toISOString().split('T')[0]
      });
      await loadData();
      setTransactions({});
      setExpandedRows(new Set());
    } else {
      showMsg('error', 'Failed to record adjustment. Check inventory balance.');
    }
  };

  // ========== TRANSFER HANDLERS ==========
  
  const handleTransferSubmit = async () => {
    const { transfer_type, from_location_id, to_location_id, commodity_id, bushels, counterparty, notes, transaction_date } = transferForm;
    
    if (!commodity_id || !bushels || !counterparty) {
      showMsg('error', 'Please fill in commodity, bushels, and counterparty');
      return;
    }
    
    const bushelsNum = parseFloat(bushels);
    if (isNaN(bushelsNum) || bushelsNum <= 0) {
      showMsg('error', 'Please enter a valid bushel amount');
      return;
    }
    
    if (transfer_type === 'SWAP') {
      // Swap requires both locations
      if (!from_location_id || !to_location_id) {
        showMsg('error', 'Please select both From and To locations for a swap');
        return;
      }
      
      // Create TRANSFER_OUT from one location
      const outResult = await recordInventoryChange(
        from_location_id,
        commodity_id,
        cropYear,
        -bushelsNum,
        'TRANSFER_OUT',
        { transaction_date, counterparty, notes: notes || `Swap with ${counterparty}` }
      );
      
      if (!outResult) {
        showMsg('error', 'Failed to record transfer out. Check inventory balance.');
        return;
      }
      
      // Create TRANSFER_IN to the other location
      const inResult = await recordInventoryChange(
        to_location_id,
        commodity_id,
        cropYear,
        bushelsNum,
        'TRANSFER_IN',
        { 
          transaction_date, 
          counterparty, 
          notes: notes || `Swap with ${counterparty}`,
          linked_transaction_id: outResult.id
        }
      );
      
      if (inResult) {
        showMsg('success', 'Swap recorded successfully');
      }
      
    } else {
      // Single transfer - either IN or OUT
      if (!from_location_id && !to_location_id) {
        showMsg('error', 'Please select a location');
        return;
      }
      
      const isTransferIn = !!to_location_id;
      const locationId = isTransferIn ? to_location_id : from_location_id;
      const transactionType = isTransferIn ? 'TRANSFER_IN' : 'TRANSFER_OUT';
      const bushelsValue = isTransferIn ? bushelsNum : -bushelsNum;
      
      const result = await recordInventoryChange(
        locationId,
        commodity_id,
        cropYear,
        bushelsValue,
        transactionType,
        { transaction_date, counterparty, notes }
      );
      
      if (result) {
        showMsg('success', `Transfer ${isTransferIn ? 'in' : 'out'} recorded successfully`);
      } else {
        showMsg('error', 'Failed to record transfer. Check inventory balance.');
        return;
      }
    }
    
    setShowTransferModal(false);
    setTransferForm({
      transfer_type: 'SINGLE', from_location_id: '', to_location_id: '',
      commodity_id: '', bushels: '', counterparty: '',
      notes: '', transaction_date: new Date().toISOString().split('T')[0]
    });
    await loadData();
    setTransactions({});
    setExpandedRows(new Set());
  };

  // ========== ADD GRAIN HANDLERS ==========
  
  const handleAddGrainSubmit = async () => {
    const { location_id, commodity_id, bushels, transaction_date, notes } = addGrainForm;
    
    if (!location_id || !commodity_id || !bushels) {
      showMsg('error', 'Please fill in location, commodity, and bushels');
      return;
    }
    
    const bushelsNum = parseFloat(bushels);
    if (isNaN(bushelsNum) || bushelsNum <= 0) {
      showMsg('error', 'Please enter a valid bushel amount');
      return;
    }
    
    const result = await recordInventoryChange(
      location_id,
      commodity_id,
      cropYear,
      bushelsNum,
      'DEPOSIT',
      { transaction_date, notes }
    );
    
    if (result) {
      showMsg('success', 'Grain added successfully');
      setShowAddGrainModal(false);
      setAddGrainForm({
        location_id: '', commodity_id: '', bushels: '',
        transaction_date: new Date().toISOString().split('T')[0], notes: ''
      });
      await loadData();
      setTransactions({});
      setExpandedRows(new Set());
    } else {
      showMsg('error', 'Failed to add grain');
    }
  };

  // ========== RENDER HELPERS ==========
  
  const getTransactionTypeStyle = (type) => {
    switch (type) {
      case 'DEPOSIT': return 'bg-green-100 text-green-800';
      case 'WITHDRAWAL': 
      case 'SALE': return 'bg-blue-100 text-blue-800';
      case 'TRANSFER_IN': return 'bg-purple-100 text-purple-800';
      case 'TRANSFER_OUT': return 'bg-orange-100 text-orange-800';
      case 'SHRINK': return 'bg-red-100 text-red-800';
      case 'RECONCILIATION': return 'bg-yellow-100 text-yellow-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const formatBushels = (n) => {
    if (n == null) return '-';
    const prefix = n > 0 ? '+' : '';
    return prefix + Math.round(n).toLocaleString();
  };

  if (loading) return <div className="flex items-center justify-center h-64"><Icon name="refresh-cw" className="animate-spin text-amber-600" size={32} /></div>;

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Inventory</h1>
          <p className="text-sm text-gray-500 mt-1">Current grain inventory by location</p>
        </div>
        <select value={cropYear} onChange={(e) => onYearChange(parseInt(e.target.value))}
          className="px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium focus:ring-2 focus:ring-amber-500">
          {cropYears.map(year => <option key={year} value={year}>{year}</option>)}
        </select>
      </div>
      
      {/* Action Buttons */}
      <div className="flex flex-wrap gap-3">
        <button onClick={() => setShowPoyModal(true)}
          className="flex items-center gap-2 px-4 py-2 bg-amber-600 text-white rounded-lg text-sm font-medium hover:bg-amber-700">
          <Icon name="file-up" size={18} /> Import POY
        </button>
        <button onClick={() => setShowAdjustModal(true)}
          className="flex items-center gap-2 px-4 py-2 bg-gray-600 text-white rounded-lg text-sm font-medium hover:bg-gray-700">
          <Icon name="scale" size={18} /> Adjust
        </button>
        <button onClick={() => setShowTransferModal(true)}
          className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg text-sm font-medium hover:bg-purple-700">
          <Icon name="arrow-right-left" size={18} /> Transfer
        </button>
        <button onClick={() => setShowAddGrainModal(true)}
          className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg text-sm font-medium hover:bg-green-700">
          <Icon name="plus" size={18} /> Add Grain
        </button>
      </div>

      {/* Messages */}
      {message && (
        <div className={`p-4 rounded-lg ${message.type === 'success' ? 'bg-green-50 text-green-800 border border-green-200' : 'bg-red-50 text-red-800 border border-red-200'}`}>
          {message.text}
        </div>
      )}

      {/* Inventory Table */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
        <table className="w-full text-sm">
          <thead className="bg-gray-50 border-b border-gray-200">
            <tr>
              <th className="w-8 px-2 py-3"></th>
              <th className="text-left px-4 py-3 font-semibold text-gray-700">Location</th>
              <th className="text-left px-4 py-3 font-semibold text-gray-700">Commodity</th>
              <th className="text-right px-4 py-3 font-semibold text-gray-700">Bushels</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-100">
            {inventory.map(item => {
              const key = `${item.location_id}-${item.commodity_id}`;
              const isExpanded = expandedRows.has(key);
              const itemTransactions = transactions[key] || [];
              
              return (
                <React.Fragment key={item.id}>
                  <tr className="hover:bg-gray-50 cursor-pointer" onClick={() => toggleRow(item)}>
                    <td className="px-2 py-3 text-center">
                      <Icon name={isExpanded ? 'chevron-down' : 'chevron-right'} size={16} className="text-gray-400" />
                    </td>
                    <td className="px-4 py-3 font-medium text-gray-900">{item.location_name}</td>
                    <td className="px-4 py-3 text-gray-600">{item.commodity_name}</td>
                    <td className="px-4 py-3 text-right font-medium text-gray-900">{Math.round(item.bushels).toLocaleString()}</td>
                  </tr>
                  {isExpanded && (
                    <tr>
                      <td colSpan={4} className="bg-gray-50 px-4 py-3">
                        <div className="ml-6">
                          <h4 className="font-medium text-gray-700 mb-2 flex items-center gap-2">
                            <Icon name="history" size={16} /> Transaction History
                          </h4>
                          {itemTransactions.length === 0 ? (
                            <p className="text-gray-500 text-sm">No transactions recorded</p>
                          ) : (
                            <div className="overflow-x-auto">
                              <table className="w-full text-xs">
                                <thead>
                                  <tr className="text-gray-500">
                                    <th className="text-left py-1 pr-4">Date</th>
                                    <th className="text-left py-1 pr-4">Type</th>
                                    <th className="text-right py-1 pr-4">Bushels</th>
                                    <th className="text-left py-1 pr-4">Counterparty</th>
                                    <th className="text-left py-1">Notes</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  {itemTransactions.map(tx => (
                                    <tr key={tx.id} className="border-t border-gray-200">
                                      <td className="py-2 pr-4 text-gray-600">{tx.transaction_date}</td>
                                      <td className="py-2 pr-4">
                                        <span className={`px-2 py-0.5 rounded text-xs font-medium ${getTransactionTypeStyle(tx.transaction_type)}`}>
                                          {tx.transaction_type.replace('_', ' ')}
                                        </span>
                                      </td>
                                      <td className={`py-2 pr-4 text-right font-medium ${tx.bushels >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                                        {formatBushels(tx.bushels)}
                                      </td>
                                      <td className="py-2 pr-4 text-gray-600">{tx.counterparty || '-'}</td>
                                      <td className="py-2 text-gray-500 truncate max-w-xs" title={tx.notes || tx.reason || tx.ticket_numbers}>
                                        {tx.notes || tx.reason || (tx.ticket_numbers ? `Tickets: ${tx.ticket_numbers.substring(0, 30)}...` : '-')}
                                      </td>
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          )}
                        </div>
                      </td>
                    </tr>
                  )}
                </React.Fragment>
              );
            })}
          </tbody>
        </table>
        {inventory.length === 0 && (
          <div className="p-8 text-center text-gray-500">
            <Icon name="package" size={48} className="mx-auto mb-4 text-gray-300" />
            <p>No inventory for {cropYear}</p>
          </div>
        )}
      </div>

      {/* POY Import Modal */}
      {showPoyModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-xl shadow-xl max-w-3xl w-full max-h-[90vh] overflow-y-auto">
            <div className="p-6 border-b border-gray-200 flex items-center justify-between">
              <h2 className="text-xl font-bold text-gray-900">Import Proof of Yield</h2>
              <button onClick={() => { setShowPoyModal(false); setPoyFile(null); setPoyData(null); setPoyError(null); }}
                className="text-gray-400 hover:text-gray-600">
                <Icon name="x" size={24} />
              </button>
            </div>
            
            <div className="p-6 space-y-6">
              {/* File Upload */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">Select PDF File</label>
                <input type="file" accept=".pdf" onChange={handlePoyFileSelect}
                  className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-amber-50 file:text-amber-700 hover:file:bg-amber-100" />
                {poyFile && (
                  <p className="mt-2 text-sm text-gray-600">Selected: {poyFile.name}</p>
                )}
              </div>
              
              {/* Parse Button */}
              {poyFile && !poyData && (
                <button onClick={handlePoyParse} disabled={poyParsing}
                  className="flex items-center gap-2 px-4 py-2 bg-amber-600 text-white rounded-lg text-sm font-medium hover:bg-amber-700 disabled:opacity-50">
                  {poyParsing ? (
                    <><Icon name="loader" size={18} className="animate-spin" /> Parsing with Claude...</>
                  ) : (
                    <><Icon name="search" size={18} /> Parse Document</>
                  )}
                </button>
              )}
              
              {/* Error */}
              {poyError && (
                <div className="p-4 bg-red-50 text-red-700 rounded-lg border border-red-200">
                  <strong>Error:</strong> {poyError}
                </div>
              )}
              
              {/* Parsed Data Preview */}
              {poyData && (
                <>
                  <div className="p-4 bg-green-50 rounded-lg border border-green-200">
                    <h3 className="font-medium text-green-800 mb-2">Parsed Successfully</h3>
                    <p className="text-sm text-green-700">
                      Producer: {poyData.producer_name || 'Unknown'} | 
                      Crop Year: {poyData.crop_year} | 
                      Tickets: {poyData.deliveries?.length || 0}
                    </p>
                  </div>
                  
                  {/* Totals */}
                  <div className="grid grid-cols-2 sm:grid-cols-4 gap-4">
                    {Object.entries(poyData.totals_by_commodity || {}).map(([commodity, total]) => (
                      <div key={commodity} className="p-3 bg-gray-50 rounded-lg text-center">
                        <div className="text-lg font-bold text-gray-900">{Math.round(total).toLocaleString()}</div>
                        <div className="text-xs text-gray-500">{commodity}</div>
                      </div>
                    ))}
                  </div>
                  
                  {/* Duplicate Warning */}
                  {poyDuplicates.length > 0 && (
                    <div className="p-4 bg-yellow-50 text-yellow-800 rounded-lg border border-yellow-200">
                      <strong>Warning:</strong> {poyDuplicates.length} tickets already imported and will be skipped.
                    </div>
                  )}
                  
                  {/* Location Mapping */}
                  <div>
                    <h3 className="font-medium text-gray-900 mb-3">Map Elevator Locations</h3>
                    <div className="space-y-3">
                      {[...new Set(poyData.deliveries?.map(d => d.location) || [])].map(elevatorLoc => (
                        <div key={elevatorLoc} className="flex items-center gap-4">
                          <span className="text-sm text-gray-700 w-40 truncate" title={elevatorLoc}>{elevatorLoc}</span>
                          <Icon name="arrow-right-left" size={16} className="text-gray-400" />
                          <select 
                            value={poyMappings[elevatorLoc] || ''}
                            onChange={(e) => setPoyMappings(prev => ({ ...prev, [elevatorLoc]: e.target.value }))}
                            className={`flex-1 px-3 py-2 border rounded-lg text-sm ${poyMappings[elevatorLoc] ? 'border-green-300 bg-green-50' : 'border-red-300 bg-red-50'}`}
                          >
                            <option value="">-- Select Location --</option>
                            {locations.map(loc => (
                              <option key={loc.id} value={loc.id}>{loc.name}</option>
                            ))}
                          </select>
                        </div>
                      ))}
                    </div>
                  </div>
                  
                  {/* Import Button */}
                  <button onClick={handlePoyImport} disabled={poyImporting}
                    className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700 disabled:opacity-50">
                    {poyImporting ? (
                      <><Icon name="loader" size={18} className="animate-spin" /> Importing...</>
                    ) : (
                      <><Icon name="check" size={18} /> Import {(poyData.deliveries?.length || 0) - poyDuplicates.length} Tickets</>
                    )}
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Adjustment Modal */}
      {showAdjustModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-xl shadow-xl max-w-md w-full">
            <div className="p-6 border-b border-gray-200 flex items-center justify-between">
              <h2 className="text-xl font-bold text-gray-900">Inventory Adjustment</h2>
              <button onClick={() => setShowAdjustModal(false)} className="text-gray-400 hover:text-gray-600">
                <Icon name="x" size={24} />
              </button>
            </div>
            
            <div className="p-6 space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Adjustment Type</label>
                <select value={adjustForm.adjustment_type} onChange={(e) => setAdjustForm(f => ({ ...f, adjustment_type: e.target.value }))}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                  <option value="SHRINK">Shrink (moisture/handling loss)</option>
                  <option value="RECONCILIATION">Reconciliation (inventory count)</option>
                </select>
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Location *</label>
                  <select value={adjustForm.location_id} onChange={(e) => setAdjustForm(f => ({ ...f, location_id: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                    <option value="">Select...</option>
                    {locations.map(loc => <option key={loc.id} value={loc.id}>{loc.name}</option>)}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Commodity *</label>
                  <select value={adjustForm.commodity_id} onChange={(e) => setAdjustForm(f => ({ ...f, commodity_id: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                    <option value="">Select...</option>
                    {commodities.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                  </select>
                </div>
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Bushels * {adjustForm.adjustment_type === 'SHRINK' ? '(loss amount)' : '(+ or -)'}
                  </label>
                  <input type="number" value={adjustForm.bushels} onChange={(e) => setAdjustForm(f => ({ ...f, bushels: e.target.value }))}
                    placeholder={adjustForm.adjustment_type === 'SHRINK' ? 'e.g., 500' : 'e.g., -500 or 500'}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Date</label>
                  <input type="date" value={adjustForm.transaction_date} onChange={(e) => setAdjustForm(f => ({ ...f, transaction_date: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                </div>
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Reason *</label>
                <input type="text" value={adjustForm.reason} onChange={(e) => setAdjustForm(f => ({ ...f, reason: e.target.value }))}
                  placeholder={adjustForm.adjustment_type === 'SHRINK' ? 'e.g., 2% moisture shrink' : 'e.g., Physical count reconciliation'}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
              </div>
              
              <button onClick={handleAdjustSubmit}
                className="w-full px-4 py-2 bg-gray-700 text-white rounded-lg font-medium hover:bg-gray-800">
                Record Adjustment
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Transfer Modal */}
      {showTransferModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-xl shadow-xl max-w-md w-full">
            <div className="p-6 border-b border-gray-200 flex items-center justify-between">
              <h2 className="text-xl font-bold text-gray-900">Grain Transfer</h2>
              <button onClick={() => setShowTransferModal(false)} className="text-gray-400 hover:text-gray-600">
                <Icon name="x" size={24} />
              </button>
            </div>
            
            <div className="p-6 space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Transfer Type</label>
                <div className="flex gap-4">
                  <label className="flex items-center gap-2">
                    <input type="radio" name="transfer_type" value="SINGLE" checked={transferForm.transfer_type === 'SINGLE'}
                      onChange={(e) => setTransferForm(f => ({ ...f, transfer_type: e.target.value }))} />
                    <span className="text-sm">Single (In or Out)</span>
                  </label>
                  <label className="flex items-center gap-2">
                    <input type="radio" name="transfer_type" value="SWAP" checked={transferForm.transfer_type === 'SWAP'}
                      onChange={(e) => setTransferForm(f => ({ ...f, transfer_type: e.target.value }))} />
                    <span className="text-sm">Swap (Between Locations)</span>
                  </label>
                </div>
              </div>
              
              {transferForm.transfer_type === 'SWAP' ? (
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">From Location *</label>
                    <select value={transferForm.from_location_id} onChange={(e) => setTransferForm(f => ({ ...f, from_location_id: e.target.value }))}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                      <option value="">Select...</option>
                      {locations.map(loc => <option key={loc.id} value={loc.id}>{loc.name}</option>)}
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">To Location *</label>
                    <select value={transferForm.to_location_id} onChange={(e) => setTransferForm(f => ({ ...f, to_location_id: e.target.value }))}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                      <option value="">Select...</option>
                      {locations.map(loc => <option key={loc.id} value={loc.id}>{loc.name}</option>)}
                    </select>
                  </div>
                </div>
              ) : (
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Transfer Out From</label>
                    <select value={transferForm.from_location_id} onChange={(e) => setTransferForm(f => ({ ...f, from_location_id: e.target.value, to_location_id: '' }))}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                      <option value="">Select...</option>
                      {locations.map(loc => <option key={loc.id} value={loc.id}>{loc.name}</option>)}
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Transfer In To</label>
                    <select value={transferForm.to_location_id} onChange={(e) => setTransferForm(f => ({ ...f, to_location_id: e.target.value, from_location_id: '' }))}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                      <option value="">Select...</option>
                      {locations.map(loc => <option key={loc.id} value={loc.id}>{loc.name}</option>)}
                    </select>
                  </div>
                </div>
              )}
              
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Commodity *</label>
                  <select value={transferForm.commodity_id} onChange={(e) => setTransferForm(f => ({ ...f, commodity_id: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                    <option value="">Select...</option>
                    {commodities.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Bushels *</label>
                  <input type="number" value={transferForm.bushels} onChange={(e) => setTransferForm(f => ({ ...f, bushels: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                </div>
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Counterparty *</label>
                  <input type="text" value={transferForm.counterparty} onChange={(e) => setTransferForm(f => ({ ...f, counterparty: e.target.value }))}
                    placeholder="e.g., Dwight Baldwin"
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Date</label>
                  <input type="date" value={transferForm.transaction_date} onChange={(e) => setTransferForm(f => ({ ...f, transaction_date: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                </div>
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Notes</label>
                <input type="text" value={transferForm.notes} onChange={(e) => setTransferForm(f => ({ ...f, notes: e.target.value }))}
                  placeholder="Optional notes"
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
              </div>
              
              <button onClick={handleTransferSubmit}
                className="w-full px-4 py-2 bg-purple-600 text-white rounded-lg font-medium hover:bg-purple-700">
                Record Transfer
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Add Grain Modal */}
      {showAddGrainModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-xl shadow-xl max-w-md w-full">
            <div className="p-6 border-b border-gray-200 flex items-center justify-between">
              <h2 className="text-xl font-bold text-gray-900">Add Grain to Inventory</h2>
              <button onClick={() => setShowAddGrainModal(false)} className="text-gray-400 hover:text-gray-600">
                <Icon name="x" size={24} />
              </button>
            </div>
            
            <div className="p-6 space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Location *</label>
                  <select value={addGrainForm.location_id} onChange={(e) => setAddGrainForm(f => ({ ...f, location_id: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                    <option value="">Select...</option>
                    {locations.map(loc => <option key={loc.id} value={loc.id}>{loc.name}</option>)}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Commodity *</label>
                  <select value={addGrainForm.commodity_id} onChange={(e) => setAddGrainForm(f => ({ ...f, commodity_id: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg">
                    <option value="">Select...</option>
                    {commodities.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                  </select>
                </div>
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Bushels *</label>
                  <input type="number" value={addGrainForm.bushels} onChange={(e) => setAddGrainForm(f => ({ ...f, bushels: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Date</label>
                  <input type="date" value={addGrainForm.transaction_date} onChange={(e) => setAddGrainForm(f => ({ ...f, transaction_date: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                </div>
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Notes</label>
                <input type="text" value={addGrainForm.notes} onChange={(e) => setAddGrainForm(f => ({ ...f, notes: e.target.value }))}
                  placeholder="Optional notes"
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
              </div>
              
              <button onClick={handleAddGrainSubmit}
                className="w-full px-4 py-2 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700">
                Add to Inventory
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Settings Page
function SettingsPage({ isConnected }) {
  const [testing, setTesting] = useState(false);
  const [testResult, setTestResult] = useState(null);

  const handleTestConnection = async () => {
    setTesting(true);
    setTestResult(null);
    const result = await testConnection();
    setTestResult(result);
    setTesting(false);
  };

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-bold text-gray-900">Settings</h1>
        <p className="text-sm text-gray-500 mt-1">System configuration and connection status</p>
      </div>

      {/* Connection Status */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
        <div className="px-5 py-4 border-b border-gray-100 bg-gray-50 flex items-center gap-2">
          <Icon name="database" size={20} className="text-gray-600" />
          <h2 className="font-semibold text-gray-900">Database Connection</h2>
        </div>
        <div className="p-5 space-y-4">
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">Connection Status</span>
            <div className={`flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium ${
              isConnected === null ? 'bg-gray-100 text-gray-600' :
              isConnected ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'
            }`}>
              {isConnected === null ? (
                <><Icon name="refresh-cw" className="animate-spin" size={14} /> Checking...</>
              ) : isConnected ? (
                <><Icon name="check-circle" size={14} /> Connected</>
              ) : (
                <><Icon name="x-circle" size={14} /> Not Connected</>
              )}
            </div>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">Database</span>
            <span className="text-sm font-mono text-gray-900">Chemical Project (Supabase)</span>
          </div>
          <div className="pt-4 border-t border-gray-100">
            <button onClick={handleTestConnection} disabled={testing}
              className="px-4 py-2 bg-amber-600 text-white rounded-lg text-sm font-medium hover:bg-amber-700 disabled:opacity-50 flex items-center gap-2">
              {testing ? <Icon name="refresh-cw" className="animate-spin" size={16} /> : <Icon name="database" size={16} />}
              Test Connection
            </button>
            {testResult !== null && (
              <p className={`mt-2 text-sm ${testResult ? 'text-green-600' : 'text-red-600'}`}>
                {testResult ? 'OK: Connection successful' : 'FAIL: Connection failed'}
              </p>
            )}
          </div>
        </div>
      </div>

      {/* App Info */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
        <div className="px-5 py-4 border-b border-gray-100 bg-gray-50 flex items-center gap-2">
          <Icon name="info" size={20} className="text-gray-600" />
          <h2 className="font-semibold text-gray-900">Application Info</h2>
        </div>
        <div className="p-5 space-y-3">
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">App Name</span>
            <span className="text-sm font-medium text-gray-900">GrainTrack Suite</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">Version</span>
            <span className="text-sm font-mono text-gray-900">1.7.0</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">Release</span>
            <span className="text-sm text-gray-900">POY Import & Transfers</span>
          </div>
        </div>
      </div>

      {/* v1.7.0 Features */}
      <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
        <div className="px-5 py-4 border-b border-gray-100 bg-gray-50 flex items-center gap-2">
          <Icon name="settings" size={20} className="text-gray-600" />
          <h2 className="font-semibold text-gray-900">v1.7.0 Features</h2>
        </div>
        <div className="p-5">
          <ul className="space-y-2 text-sm text-gray-600">
            <li className="flex items-center gap-2"><Icon name="check-circle" className="text-green-500" size={16} /> POY Import via Claude API</li>
            <li className="flex items-center gap-2"><Icon name="check-circle" className="text-green-500" size={16} /> Inventory transaction audit trail</li>
            <li className="flex items-center gap-2"><Icon name="check-circle" className="text-green-500" size={16} /> Shrink and reconciliation adjustments</li>
            <li className="flex items-center gap-2"><Icon name="check-circle" className="text-green-500" size={16} /> Transfer functionality (single and swap)</li>
            <li className="flex items-center gap-2"><Icon name="check-circle" className="text-green-500" size={16} /> Elevator location mapping</li>
            <li className="flex items-center gap-2"><Icon name="check-circle" className="text-green-500" size={16} /> Ticket-level duplicate detection</li>
          </ul>
        </div>
      </div>
    </div>
  );
}

// ============================================================================
// MAIN APP
// ============================================================================
function App() {
  const [currentPage, setCurrentPage] = useState('dashboard');
  const [isConnected, setIsConnected] = useState(null);
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [user, setUser] = useState(null);
  const [authLoading, setAuthLoading] = useState(true);
  const currentYear = new Date().getFullYear();
  const [selectedCropYear, setSelectedCropYear] = useState(currentYear);

  // Check authentication
  useEffect(() => {
    async function checkAuth() {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        window.location.href = 'login.html';
        return;
      }
      setUser(session.user);
      setAuthLoading(false);
    }
    checkAuth();

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      if (event === 'SIGNED_OUT' || !session) {
        window.location.href = 'login.html';
      } else {
        setUser(session.user);
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  useEffect(() => { testConnection().then(setIsConnected); }, []);

  // Logout handler
  const handleLogout = async () => {
    await supabase.auth.signOut();
    window.location.href = 'login.html';
  };

  // Show loading while checking auth
  if (authLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <Icon name="refresh-cw" className="animate-spin text-amber-600 mx-auto mb-4" size={32} />
          <p className="text-gray-500">Loading...</p>
        </div>
      </div>
    );
  }

  const renderPage = () => {
    switch (currentPage) {
      case 'dashboard': return <DashboardPage cropYear={selectedCropYear} onYearChange={setSelectedCropYear} />;
      case 'add-sale': return <AddSalePage cropYear={selectedCropYear} onSuccess={() => setCurrentPage('contracts')} onYearChange={setSelectedCropYear} />;
      case 'contracts': return <ContractsPage cropYear={selectedCropYear} onYearChange={setSelectedCropYear} />;
      case 'production': return <ProductionPage cropYear={selectedCropYear} onYearChange={setSelectedCropYear} />;
      case 'inventory': return <InventoryPage cropYear={selectedCropYear} onYearChange={setSelectedCropYear} />;
      case 'insurance': return <InsurancePage cropYear={selectedCropYear} onYearChange={setSelectedCropYear} />;
      case 'buyers': return <BuyersPage />;
      case 'storage': return <StoragePage />;
      case 'basis': return <BasisPage />;
      case 'settings': return <SettingsPage isConnected={isConnected} />;
      default: return <DashboardPage cropYear={selectedCropYear} onYearChange={setSelectedCropYear} />;
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Mobile header */}
      <div className="lg:hidden bg-white border-b border-gray-200 px-4 py-3 flex items-center justify-between">
        <div className="flex items-center gap-3">
          <button onClick={() => setIsSidebarOpen(true)} className="p-2 hover:bg-gray-100 rounded-lg">
            <Icon name="menu" size={20} />
          </button>
          <div className="flex items-center gap-2">
            <Icon name="wheat" size={24} className="text-amber-600" />
            <span className="font-bold text-gray-900">GrainTrack</span>
          </div>
        </div>
        <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : isConnected === false ? 'bg-red-500' : 'bg-gray-300'}`} />
      </div>

      {/* Mobile sidebar overlay */}
      {isSidebarOpen && (
        <div className="lg:hidden fixed inset-0 z-50">
          <div className="fixed inset-0 bg-black bg-opacity-50" onClick={() => setIsSidebarOpen(false)} />
          <div className="fixed left-0 top-0 bottom-0 w-64 bg-white shadow-xl">
            <div className="p-4 border-b border-gray-200 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <Icon name="wheat" size={24} className="text-amber-600" />
                <span className="font-bold text-gray-900">GrainTrack</span>
              </div>
              <button onClick={() => setIsSidebarOpen(false)} className="p-2 hover:bg-gray-100 rounded-lg">
                <Icon name="x" size={20} />
              </button>
            </div>
            <nav className="p-2">
              {navItems.map(item => (
                <button key={item.id} onClick={() => { setCurrentPage(item.id); setIsSidebarOpen(false); }}
                  className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg text-left mb-1 ${
                    currentPage === item.id ? 'bg-amber-100 text-amber-900' : 'text-gray-600 hover:bg-gray-100'}`}>
                  <Icon name={item.icon} size={20} />
                  <span className="font-medium">{item.label}</span>
                </button>
              ))}
            </nav>
            {user && (
              <div className="absolute bottom-0 left-0 right-0 p-4 border-t border-gray-200">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm text-gray-600 truncate">{user.email}</span>
                </div>
                <button onClick={handleLogout}
                  className="w-full flex items-center justify-center gap-2 px-4 py-2 text-red-600 hover:bg-red-50 rounded-lg">
                  <Icon name="log-out" size={18} />
                  <span className="font-medium">Sign Out</span>
                </button>
              </div>
            )}
          </div>
        </div>
      )}

      <div className="lg:flex">
        {/* Desktop sidebar */}
        <div className="hidden lg:block w-64 min-h-screen bg-white border-r border-gray-200">
          <div className="p-4 border-b border-gray-200">
            <div className="flex items-center gap-2">
              <Icon name="wheat" size={28} className="text-amber-600" />
              <div>
                <div className="font-bold text-gray-900">GrainTrack Suite</div>
                <div className="text-xs text-gray-500">v1.7.1</div>
              </div>
            </div>
          </div>
          <nav className="p-2">
            {navItems.map(item => (
              <button key={item.id} onClick={() => setCurrentPage(item.id)}
                className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg text-left mb-1 ${
                  currentPage === item.id ? 'bg-amber-100 text-amber-900' : 'text-gray-600 hover:bg-gray-100'}`}>
                <Icon name={item.icon} size={20} />
                <span className="font-medium">{item.label}</span>
              </button>
            ))}
          </nav>
          <div className="absolute bottom-0 left-0 w-64 p-4 border-t border-gray-200 space-y-3">
            {user && (
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2 min-w-0">
                  <div className="w-8 h-8 rounded-full bg-amber-100 flex items-center justify-center flex-shrink-0">
                    <Icon name="user" size={16} className="text-amber-600" />
                  </div>
                  <span className="text-sm text-gray-700 truncate">{user.email}</span>
                </div>
                <button onClick={handleLogout} className="p-2 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-lg" title="Sign out">
                  <Icon name="log-out" size={18} />
                </button>
              </div>
            )}
            <div className="flex items-center gap-2">
              <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : isConnected === false ? 'bg-red-500' : 'bg-gray-300'}`} />
              <span className="text-sm text-gray-500">{isConnected ? 'Connected' : isConnected === false ? 'Disconnected' : 'Checking...'}</span>
            </div>
          </div>
        </div>

        {/* Main content */}
        <div className="flex-1 p-4 lg:p-8">
          {renderPage()}
        </div>
      </div>
    </div>
  );
}

// Render the app
ReactDOM.createRoot(document.getElementById('root')).render(
  <ToastProvider>
    <App />
  </ToastProvider>
);
</script>
</body>
</html>
